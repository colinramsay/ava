// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: non_constant_identifier_names, camel_case_types, unused_element, constant_identifier_names

import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Get a string representation of a notmuch_status_t value.
  ///
  /// The result is read-only.
  ffi.Pointer<ffi.Int8> notmuch_status_to_string(
    int status,
  ) {
    return _notmuch_status_to_string(
      status,
    );
  }

  late final _notmuch_status_to_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'notmuch_status_to_string');
  late final _notmuch_status_to_string = _notmuch_status_to_stringPtr
      .asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// Create a new, empty notmuch database located at 'path'.
  ///
  /// The path should be a top-level directory to a collection of
  /// plain-text email messages (one message per file). This call will
  /// create a new ".notmuch" directory within 'path' where notmuch will
  /// store its data.
  ///
  /// After a successful call to notmuch_database_create, the returned
  /// database will be open so the caller should call
  /// notmuch_database_destroy when finished with it.
  ///
  /// The database will not yet have any data in it
  /// (notmuch_database_create itself is a very cheap function). Messages
  /// contained within 'path' can be added to the database by calling
  /// notmuch_database_index_file.
  ///
  /// In case of any failure, this function returns an error status and
  /// sets *database to NULL (after printing an error message on stderr).
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successfully created the database.
  ///
  /// NOTMUCH_STATUS_NULL_POINTER: The given 'path' argument is NULL.
  ///
  /// NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory.
  ///
  /// NOTMUCH_STATUS_FILE_ERROR: An error occurred trying to create the
  /// database file (such as permission denied, or file not found,
  /// etc.), or the database already exists.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred.
  int notmuch_database_create(
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
  ) {
    return _notmuch_database_create(
      path,
      database,
    );
  }

  late final _notmuch_database_createPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>)>>(
      'notmuch_database_create');
  late final _notmuch_database_create = _notmuch_database_createPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<notmuch_database_t>>)>();

  /// Like notmuch_database_create, except optionally return an error
  /// message. This message is allocated by malloc and should be freed by
  /// the caller.
  int notmuch_database_create_verbose(
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> error_message,
  ) {
    return _notmuch_database_create_verbose(
      path,
      database,
      error_message,
    );
  }

  late final _notmuch_database_create_verbosePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_create_verbose');
  late final _notmuch_database_create_verbose =
      _notmuch_database_create_verbosePtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Deprecated alias for notmuch_database_open_with_config with
  /// config_path="" and error_message=NULL
  /// @deprecated Deprecated as of libnotmuch 5.4 (notmuch 0.32)
  int notmuch_database_open(
    ffi.Pointer<ffi.Int8> path,
    int mode,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
  ) {
    return _notmuch_database_open(
      path,
      mode,
      database,
    );
  }

  late final _notmuch_database_openPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Int32,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>)>>(
      'notmuch_database_open');
  late final _notmuch_database_open = _notmuch_database_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, int,
          ffi.Pointer<ffi.Pointer<notmuch_database_t>>)>();

  /// Deprecated alias for notmuch_database_open_with_config with
  /// config_path=""
  ///
  /// @deprecated Deprecated as of libnotmuch 5.4 (notmuch 0.32)
  int notmuch_database_open_verbose(
    ffi.Pointer<ffi.Int8> path,
    int mode,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> error_message,
  ) {
    return _notmuch_database_open_verbose(
      path,
      mode,
      database,
      error_message,
    );
  }

  late final _notmuch_database_open_verbosePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Int8>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_open_verbose');
  late final _notmuch_database_open_verbose =
      _notmuch_database_open_verbosePtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int8>,
              int,
              ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Open an existing notmuch database located at 'database_path', using
  /// configuration in 'config_path'.
  ///
  /// @param[in]	database_path
  /// @parblock
  /// Path to existing database.
  ///
  /// A notmuch database is a Xapian database containing appropriate
  /// metadata.
  ///
  /// The database should have been created at some time in the past,
  /// (not necessarily by this process), by calling
  /// notmuch_database_create.
  ///
  /// If 'database_path' is NULL, use the location specified
  ///
  /// - in the environment variable NOTMUCH_DATABASE, if non-empty
  ///
  /// - in a configuration file, located as described under 'config_path'
  ///
  /// - by $XDG_DATA_HOME/notmuch/$PROFILE where XDG_DATA_HOME defaults
  /// to "$HOME/.local/share" and PROFILE as as discussed in
  /// 'profile'
  ///
  /// If 'database_path' is non-NULL, but does not appear to be a Xapian
  /// database, check for a directory '.notmuch/xapian' below
  /// 'database_path' (this is the behavior of
  /// notmuch_database_open_verbose pre-0.32).
  ///
  /// @endparblock
  /// @param[in]	mode
  /// @parblock
  /// Mode to open database. Use one of #NOTMUCH_DATABASE_MODE_READ_WRITE
  /// or #NOTMUCH_DATABASE_MODE_READ_ONLY
  ///
  /// @endparblock
  /// @param[in]  config_path
  /// @parblock
  /// Path to config file.
  ///
  /// Config file is key-value, with mandatory sections. See
  /// <em>notmuch-config(5)</em> for more information. The key-value pair
  /// overrides the corresponding configuration data stored in the
  /// database (see <em>notmuch_database_get_config</em>)
  ///
  /// If <em>config_path</em> is NULL use the path specified
  ///
  /// - in environment variable <em>NOTMUCH_CONFIG</em>, if non-empty
  ///
  /// - by  <em>XDG_CONFIG_HOME</em>/notmuch/ where
  /// XDG_CONFIG_HOME defaults to "$HOME/.config".
  ///
  /// - by $HOME/.notmuch-config
  ///
  /// If <em>config_path</em> is "" (empty string) then do not
  /// open any configuration file.
  /// @endparblock
  /// @param[in] profile:
  /// @parblock
  /// Name of profile (configuration/database variant).
  ///
  /// If non-NULL, append to the directory / file path determined for
  /// <em>config_path</em> and <em>database_path</em>.
  ///
  /// If NULL then use
  /// - environment variable NOTMUCH_PROFILE if defined,
  /// - otherwise "default" for directories and "" (empty string) for paths.
  ///
  /// @endparblock
  /// @param[out] database
  /// @parblock
  /// Pointer to database object. May not be NULL.
  ///
  /// The caller should call notmuch_database_destroy when finished with
  /// this database.
  ///
  /// In case of any failure, this function returns an error status and
  /// sets *database to NULL.
  ///
  /// @endparblock
  /// @param[out] error_message
  /// If non-NULL, store error message from opening the database.
  /// Any such message is allocated by \a malloc(3) and should be freed
  /// by the caller.
  ///
  /// @retval NOTMUCH_STATUS_SUCCESS: Successfully opened the database.
  ///
  /// @retval NOTMUCH_STATUS_NULL_POINTER: The given \a database
  /// argument is NULL.
  ///
  /// @retval NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory.
  ///
  /// @retval NOTMUCH_STATUS_FILE_ERROR: An error occurred trying to open the
  /// database or config file (such as permission denied, or file not found,
  /// etc.), or the database version is unknown.
  ///
  /// @retval NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred.
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  int notmuch_database_open_with_config(
    ffi.Pointer<ffi.Int8> database_path,
    int mode,
    ffi.Pointer<ffi.Int8> config_path,
    ffi.Pointer<ffi.Int8> profile,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> error_message,
  ) {
    return _notmuch_database_open_with_config(
      database_path,
      mode,
      config_path,
      profile,
      database,
      error_message,
    );
  }

  late final _notmuch_database_open_with_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Int8>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_open_with_config');
  late final _notmuch_database_open_with_config =
      _notmuch_database_open_with_configPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int8>,
              int,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Loads configuration from config file, database, and/or defaults
  ///
  /// For description of arguments, @see notmuch_database_open_with_config
  ///
  /// @retval NOTMUCH_STATUS_SUCCESS: Successfully loaded configuration.
  ///
  /// @retval NOTMUCH_STATUS_NO_CONFIG: No config file was loaded. Not fatal.
  ///
  /// @retval NOTMUCH_STATUS_NO_DATABASE: No config information was
  /// loaded from a database. Not fatal.
  ///
  /// @retval NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory.
  ///
  /// @retval NOTMUCH_STATUS_FILE_ERROR: An error occurred trying to open the
  /// database or config file (such as permission denied, or file not found,
  /// etc.)
  ///
  /// @retval NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred.
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  int notmuch_database_load_config(
    ffi.Pointer<ffi.Int8> database_path,
    ffi.Pointer<ffi.Int8> config_path,
    ffi.Pointer<ffi.Int8> profile,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> error_message,
  ) {
    return _notmuch_database_load_config(
      database_path,
      config_path,
      profile,
      database,
      error_message,
    );
  }

  late final _notmuch_database_load_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_load_config');
  late final _notmuch_database_load_config =
      _notmuch_database_load_configPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Create a new notmuch database located at 'database_path', using
  /// configuration in 'config_path'.
  ///
  /// For description of arguments, @see notmuch_database_open_with_config
  ///
  /// @retval NOTMUCH_STATUS_SUCCESS: Successfully created the database.
  ///
  /// @retval NOTMUCH_STATUS_DATABASE_EXISTS: Database already exists, not created
  ///
  /// @retval NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory.
  ///
  /// @retval NOTMUCH_STATUS_FILE_ERROR: An error occurred trying to open the
  /// database or config file (such as permission denied, or file not found,
  /// etc.)
  ///
  /// @retval NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred.
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  int notmuch_database_create_with_config(
    ffi.Pointer<ffi.Int8> database_path,
    ffi.Pointer<ffi.Int8> config_path,
    ffi.Pointer<ffi.Int8> profile,
    ffi.Pointer<ffi.Pointer<notmuch_database_t>> database,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> error_message,
  ) {
    return _notmuch_database_create_with_config(
      database_path,
      config_path,
      profile,
      database,
      error_message,
    );
  }

  late final _notmuch_database_create_with_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_create_with_config');
  late final _notmuch_database_create_with_config =
      _notmuch_database_create_with_configPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_database_t>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Retrieve last status string for given database.
  ffi.Pointer<ffi.Int8> notmuch_database_status_string(
    ffi.Pointer<notmuch_database_t> notmuch,
  ) {
    return _notmuch_database_status_string(
      notmuch,
    );
  }

  late final _notmuch_database_status_stringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_database_t>)>>(
      'notmuch_database_status_string');
  late final _notmuch_database_status_string =
      _notmuch_database_status_stringPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_database_t>)>();

  /// Commit changes and close the given notmuch database.
  ///
  /// After notmuch_database_close has been called, calls to other
  /// functions on objects derived from this database may either behave
  /// as if the database had not been closed (e.g., if the required data
  /// has been cached) or may fail with a
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION. The only further operation
  /// permitted on the database itself is to call
  /// notmuch_database_destroy.
  ///
  /// notmuch_database_close can be called multiple times.  Later calls
  /// have no effect.
  ///
  /// For writable databases, notmuch_database_close commits all changes
  /// to disk before closing the database, unless the caller is currently
  /// in an atomic section (there was a notmuch_database_begin_atomic
  /// without a matching notmuch_database_end_atomic). In this case
  /// changes since the last commit are discarded. @see
  /// notmuch_database_end_atomic for more information.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successfully closed the database.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred; the
  /// database has been closed but there are no guarantees the
  /// changes to the database, if any, have been flushed to disk.
  int notmuch_database_close(
    ffi.Pointer<notmuch_database_t> database,
  ) {
    return _notmuch_database_close(
      database,
    );
  }

  late final _notmuch_database_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_database_t>)>>('notmuch_database_close');
  late final _notmuch_database_close = _notmuch_database_closePtr
      .asFunction<int Function(ffi.Pointer<notmuch_database_t>)>();

  /// Compact a notmuch database, backing up the original database to the
  /// given path.
  ///
  /// The database will be opened with NOTMUCH_DATABASE_MODE_READ_WRITE
  /// during the compaction process to ensure no writes are made.
  ///
  /// If the optional callback function 'status_cb' is non-NULL, it will
  /// be called with diagnostic and informational messages. The argument
  /// 'closure' is passed verbatim to any callback invoked.
  int notmuch_database_compact(
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> backup_path,
    notmuch_compact_status_cb_t status_cb,
    ffi.Pointer<ffi.Void> closure,
  ) {
    return _notmuch_database_compact(
      path,
      backup_path,
      status_cb,
      closure,
    );
  }

  late final _notmuch_database_compactPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              notmuch_compact_status_cb_t,
              ffi.Pointer<ffi.Void>)>>('notmuch_database_compact');
  late final _notmuch_database_compact =
      _notmuch_database_compactPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              notmuch_compact_status_cb_t, ffi.Pointer<ffi.Void>)>();

  /// Like notmuch_database_compact, but take an open database as a
  /// parameter.
  ///
  /// @since libnnotmuch 5.4 (notmuch 0.32)
  int notmuch_database_compact_db(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> backup_path,
    notmuch_compact_status_cb_t status_cb,
    ffi.Pointer<ffi.Void> closure,
  ) {
    return _notmuch_database_compact_db(
      database,
      backup_path,
      status_cb,
      closure,
    );
  }

  late final _notmuch_database_compact_dbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>,
              notmuch_compact_status_cb_t,
              ffi.Pointer<ffi.Void>)>>('notmuch_database_compact_db');
  late final _notmuch_database_compact_db =
      _notmuch_database_compact_dbPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              notmuch_compact_status_cb_t, ffi.Pointer<ffi.Void>)>();

  /// Destroy the notmuch database, closing it if necessary and freeing
  /// all associated resources.
  ///
  /// Return value as in notmuch_database_close if the database was open;
  /// notmuch_database_destroy itself has no failure modes.
  int notmuch_database_destroy(
    ffi.Pointer<notmuch_database_t> database,
  ) {
    return _notmuch_database_destroy(
      database,
    );
  }

  late final _notmuch_database_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_database_t>)>>('notmuch_database_destroy');
  late final _notmuch_database_destroy = _notmuch_database_destroyPtr
      .asFunction<int Function(ffi.Pointer<notmuch_database_t>)>();

  /// Return the database path of the given database.
  ///
  /// The return value is a string owned by notmuch so should not be
  /// modified nor freed by the caller.
  ffi.Pointer<ffi.Int8> notmuch_database_get_path(
    ffi.Pointer<notmuch_database_t> database,
  ) {
    return _notmuch_database_get_path(
      database,
    );
  }

  late final _notmuch_database_get_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_database_t>)>>('notmuch_database_get_path');
  late final _notmuch_database_get_path =
      _notmuch_database_get_pathPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_database_t>)>();

  /// Return the database format version of the given database.
  ///
  /// @retval 0 on error
  int notmuch_database_get_version(
    ffi.Pointer<notmuch_database_t> database,
  ) {
    return _notmuch_database_get_version(
      database,
    );
  }

  late final _notmuch_database_get_versionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<notmuch_database_t>)>>(
      'notmuch_database_get_version');
  late final _notmuch_database_get_version = _notmuch_database_get_versionPtr
      .asFunction<int Function(ffi.Pointer<notmuch_database_t>)>();

  /// Can the database be upgraded to a newer database version?
  ///
  /// If this function returns TRUE, then the caller may call
  /// notmuch_database_upgrade to upgrade the database.  If the caller
  /// does not upgrade an out-of-date database, then some functions may
  /// fail with NOTMUCH_STATUS_UPGRADE_REQUIRED.  This always returns
  /// FALSE for a read-only database because there's no way to upgrade a
  /// read-only database.
  ///
  /// Also returns FALSE if an error occurs accessing the database.
  int notmuch_database_needs_upgrade(
    ffi.Pointer<notmuch_database_t> database,
  ) {
    return _notmuch_database_needs_upgrade(
      database,
    );
  }

  late final _notmuch_database_needs_upgradePtr = _lookup<
          ffi.NativeFunction<
              notmuch_bool_t Function(ffi.Pointer<notmuch_database_t>)>>(
      'notmuch_database_needs_upgrade');
  late final _notmuch_database_needs_upgrade =
      _notmuch_database_needs_upgradePtr
          .asFunction<int Function(ffi.Pointer<notmuch_database_t>)>();

  /// Upgrade the current database to the latest supported version.
  ///
  /// This ensures that all current notmuch functionality will be
  /// available on the database.  After opening a database in read-write
  /// mode, it is recommended that clients check if an upgrade is needed
  /// (notmuch_database_needs_upgrade) and if so, upgrade with this
  /// function before making any modifications.  If
  /// notmuch_database_needs_upgrade returns FALSE, this will be a no-op.
  ///
  /// The optional progress_notify callback can be used by the caller to
  /// provide progress indication to the user. If non-NULL it will be
  /// called periodically with 'progress' as a floating-point value in
  /// the range of [0.0 .. 1.0] indicating the progress made so far in
  /// the upgrade process.  The argument 'closure' is passed verbatim to
  /// any callback invoked.
  int notmuch_database_upgrade(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Double)>>
        progress_notify,
    ffi.Pointer<ffi.Void> closure,
  ) {
    return _notmuch_database_upgrade(
      database,
      progress_notify,
      closure,
    );
  }

  late final _notmuch_database_upgradePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Double)>>,
              ffi.Pointer<ffi.Void>)>>('notmuch_database_upgrade');
  late final _notmuch_database_upgrade =
      _notmuch_database_upgradePtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Double)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Begin an atomic database operation.
  ///
  /// Any modifications performed between a successful begin and a
  /// notmuch_database_end_atomic will be applied to the database
  /// atomically.  Note that, unlike a typical database transaction, this
  /// only ensures atomicity, not durability; neither begin nor end
  /// necessarily flush modifications to disk.
  ///
  /// Atomic sections may be nested.  begin_atomic and end_atomic must
  /// always be called in pairs.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successfully entered atomic section.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred;
  /// atomic section not entered.
  int notmuch_database_begin_atomic(
    ffi.Pointer<notmuch_database_t> notmuch,
  ) {
    return _notmuch_database_begin_atomic(
      notmuch,
    );
  }

  late final _notmuch_database_begin_atomicPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_database_t>)>>(
      'notmuch_database_begin_atomic');
  late final _notmuch_database_begin_atomic = _notmuch_database_begin_atomicPtr
      .asFunction<int Function(ffi.Pointer<notmuch_database_t>)>();

  /// Indicate the end of an atomic database operation.  If repeated
  /// (with matching notmuch_database_begin_atomic) "database.autocommit"
  /// times, commit the the transaction and all previous (non-cancelled)
  /// transactions to the database.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successfully completed atomic section.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred;
  /// atomic section not ended.
  ///
  /// NOTMUCH_STATUS_UNBALANCED_ATOMIC: The database is not currently in
  /// an atomic section.
  int notmuch_database_end_atomic(
    ffi.Pointer<notmuch_database_t> notmuch,
  ) {
    return _notmuch_database_end_atomic(
      notmuch,
    );
  }

  late final _notmuch_database_end_atomicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_database_t>)>>('notmuch_database_end_atomic');
  late final _notmuch_database_end_atomic = _notmuch_database_end_atomicPtr
      .asFunction<int Function(ffi.Pointer<notmuch_database_t>)>();

  /// Return the committed database revision and UUID.
  ///
  /// The database revision number increases monotonically with each
  /// commit to the database.  Hence, all messages and message changes
  /// committed to the database (that is, visible to readers) have a last
  /// modification revision <= the committed database revision.  Any
  /// messages committed in the future will be assigned a modification
  /// revision > the committed database revision.
  ///
  /// The UUID is a NUL-terminated opaque string that uniquely identifies
  /// this database.  Two revision numbers are only comparable if they
  /// have the same database UUID.
  int notmuch_database_get_revision(
    ffi.Pointer<notmuch_database_t> notmuch,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> uuid,
  ) {
    return _notmuch_database_get_revision(
      notmuch,
      uuid,
    );
  }

  late final _notmuch_database_get_revisionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_get_revision');
  late final _notmuch_database_get_revision =
      _notmuch_database_get_revisionPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Retrieve a directory object from the database for 'path'.
  ///
  /// Here, 'path' should be a path relative to the path of 'database'
  /// (see notmuch_database_get_path), or else should be an absolute path
  /// with initial components that match the path of 'database'.
  ///
  /// If this directory object does not exist in the database, this
  /// returns NOTMUCH_STATUS_SUCCESS and sets *directory to NULL.
  ///
  /// Otherwise the returned directory object is owned by the database
  /// and as such, will only be valid until notmuch_database_destroy is
  /// called.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successfully retrieved directory.
  ///
  /// NOTMUCH_STATUS_NULL_POINTER: The given 'directory' argument is NULL.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred;
  /// directory not retrieved.
  ///
  /// NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the
  /// database to use this function.
  int notmuch_database_get_directory(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Pointer<notmuch_directory_t>> directory,
  ) {
    return _notmuch_database_get_directory(
      database,
      path,
      directory,
    );
  }

  late final _notmuch_database_get_directoryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_directory_t>>)>>(
      'notmuch_database_get_directory');
  late final _notmuch_database_get_directory =
      _notmuch_database_get_directoryPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_directory_t>>)>();

  /// Add a message file to a database, indexing it for retrieval by
  /// future searches.  If a message already exists with the same message
  /// ID as the specified file, their indexes will be merged, and this
  /// new filename will also be associated with the existing message.
  ///
  /// Here, 'filename' should be a path relative to the path of
  /// 'database' (see notmuch_database_get_path), or else should be an
  /// absolute filename with initial components that match the path of
  /// 'database'.
  ///
  /// The file should be a single mail message (not a multi-message mbox)
  /// that is expected to remain at its current location, (since the
  /// notmuch database will reference the filename, and will not copy the
  /// entire contents of the file.
  ///
  /// If another message with the same message ID already exists in the
  /// database, rather than creating a new message, this adds the search
  /// terms from the identified file to the existing message's index, and
  /// adds 'filename' to the list of filenames known for the message.
  ///
  /// The 'indexopts' parameter can be NULL (meaning, use the indexing
  /// defaults from the database), or can be an explicit choice of
  /// indexing options that should govern the indexing of this specific
  /// 'filename'.
  ///
  /// If 'message' is not NULL, then, on successful return
  /// (NOTMUCH_STATUS_SUCCESS or NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) '*message'
  /// will be initialized to a message object that can be used for things
  /// such as adding tags to the just-added message. The user should call
  /// notmuch_message_destroy when done with the message. On any failure
  /// '*message' will be set to NULL.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Message successfully added to database.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred,
  /// message not added.
  ///
  /// NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID: Message has the same message
  /// ID as another message already in the database. The new
  /// filename was successfully added to the message in the database
  /// (if not already present) and the existing message is returned.
  ///
  /// NOTMUCH_STATUS_FILE_ERROR: an error occurred trying to open the
  /// file, (such as permission denied, or file not found,
  /// etc.). Nothing added to the database.
  ///
  /// NOTMUCH_STATUS_FILE_NOT_EMAIL: the contents of filename don't look
  /// like an email message. Nothing added to the database.
  ///
  /// NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only
  /// mode so no message can be added.
  ///
  /// NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the
  /// database to use this function.
  ///
  /// @since libnotmuch 5.1 (notmuch 0.26)
  int notmuch_database_index_file(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<notmuch_indexopts_t> indexopts,
    ffi.Pointer<ffi.Pointer<notmuch_message_t>> message,
  ) {
    return _notmuch_database_index_file(
      database,
      filename,
      indexopts,
      message,
    );
  }

  late final _notmuch_database_index_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<notmuch_indexopts_t>,
                  ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>>(
      'notmuch_database_index_file');
  late final _notmuch_database_index_file =
      _notmuch_database_index_filePtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<notmuch_indexopts_t>,
              ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>();

  /// Deprecated alias for notmuch_database_index_file called with
  /// NULL indexopts.
  ///
  /// @deprecated Deprecated as of libnotmuch 5.1 (notmuch 0.26). Please
  /// use notmuch_database_index_file instead.
  int notmuch_database_add_message(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Pointer<notmuch_message_t>> message,
  ) {
    return _notmuch_database_add_message(
      database,
      filename,
      message,
    );
  }

  late final _notmuch_database_add_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>>(
      'notmuch_database_add_message');
  late final _notmuch_database_add_message =
      _notmuch_database_add_messagePtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>();

  /// Remove a message filename from the given notmuch database. If the
  /// message has no more filenames, remove the message.
  ///
  /// If the same message (as determined by the message ID) is still
  /// available via other filenames, then the message will persist in the
  /// database for those filenames. When the last filename is removed for
  /// a particular message, the database content for that message will be
  /// entirely removed.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: The last filename was removed and the
  /// message was removed from the database.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred,
  /// message not removed.
  ///
  /// NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID: This filename was removed but
  /// the message persists in the database with at least one other
  /// filename.
  ///
  /// NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only
  /// mode so no message can be removed.
  ///
  /// NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the
  /// database to use this function.
  int notmuch_database_remove_message(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _notmuch_database_remove_message(
      database,
      filename,
    );
  }

  late final _notmuch_database_remove_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_database_remove_message');
  late final _notmuch_database_remove_message =
      _notmuch_database_remove_messagePtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>)>();

  /// Find a message with the given message_id.
  ///
  /// If a message with the given message_id is found then, on successful return
  /// (NOTMUCH_STATUS_SUCCESS) '*message' will be initialized to a message
  /// object.  The caller should call notmuch_message_destroy when done with the
  /// message.
  ///
  /// On any failure or when the message is not found, this function initializes
  /// '*message' to NULL. This means, when NOTMUCH_STATUS_SUCCESS is returned, the
  /// caller is supposed to check '*message' for NULL to find out whether the
  /// message with the given message_id was found.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successful return, check '*message'.
  ///
  /// NOTMUCH_STATUS_NULL_POINTER: The given 'message' argument is NULL
  ///
  /// NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory, creating message object
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred
  int notmuch_database_find_message(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> message_id,
    ffi.Pointer<ffi.Pointer<notmuch_message_t>> message,
  ) {
    return _notmuch_database_find_message(
      database,
      message_id,
      message,
    );
  }

  late final _notmuch_database_find_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>>(
      'notmuch_database_find_message');
  late final _notmuch_database_find_message =
      _notmuch_database_find_messagePtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>();

  /// Find a message with the given filename.
  ///
  /// If the database contains a message with the given filename then, on
  /// successful return (NOTMUCH_STATUS_SUCCESS) '*message' will be initialized to
  /// a message object. The caller should call notmuch_message_destroy when done
  /// with the message.
  ///
  /// On any failure or when the message is not found, this function initializes
  /// '*message' to NULL. This means, when NOTMUCH_STATUS_SUCCESS is returned, the
  /// caller is supposed to check '*message' for NULL to find out whether the
  /// message with the given filename is found.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Successful return, check '*message'
  ///
  /// NOTMUCH_STATUS_NULL_POINTER: The given 'message' argument is NULL
  ///
  /// NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory, creating the message object
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred
  ///
  /// NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the
  /// database to use this function.
  int notmuch_database_find_message_by_filename(
    ffi.Pointer<notmuch_database_t> notmuch,
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Pointer<notmuch_message_t>> message,
  ) {
    return _notmuch_database_find_message_by_filename(
      notmuch,
      filename,
      message,
    );
  }

  late final _notmuch_database_find_message_by_filenamePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>>(
      'notmuch_database_find_message_by_filename');
  late final _notmuch_database_find_message_by_filename =
      _notmuch_database_find_message_by_filenamePtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_message_t>>)>();

  /// Return a list of all tags found in the database.
  ///
  /// This function creates a list of all tags found in the database. The
  /// resulting list contains all tags from all messages found in the database.
  ///
  /// On error this function returns NULL.
  ffi.Pointer<notmuch_tags_t> notmuch_database_get_all_tags(
    ffi.Pointer<notmuch_database_t> db,
  ) {
    return _notmuch_database_get_all_tags(
      db,
    );
  }

  late final _notmuch_database_get_all_tagsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_tags_t> Function(
                  ffi.Pointer<notmuch_database_t>)>>(
      'notmuch_database_get_all_tags');
  late final _notmuch_database_get_all_tags =
      _notmuch_database_get_all_tagsPtr.asFunction<
          ffi.Pointer<notmuch_tags_t> Function(
              ffi.Pointer<notmuch_database_t>)>();

  /// Reopen an open notmuch database.
  ///
  /// @param [in] db	open notmuch database
  /// @param [in] mode	mode (read only or read-write) for reopened database.
  ///
  /// @retval #NOTMUCH_STATUS_SUCCESS
  /// @retval #NOTMUCH_STATUS_ILLEGAL_ARGUMENT	The passed database was not open.
  /// @retval #NOTMUCH_STATUS_XAPIAN_EXCEPTION	A Xapian exception occured
  int notmuch_database_reopen(
    ffi.Pointer<notmuch_database_t> db,
    int mode,
  ) {
    return _notmuch_database_reopen(
      db,
      mode,
    );
  }

  late final _notmuch_database_reopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_database_t>,
              ffi.Int32)>>('notmuch_database_reopen');
  late final _notmuch_database_reopen = _notmuch_database_reopenPtr
      .asFunction<int Function(ffi.Pointer<notmuch_database_t>, int)>();

  /// Create a new query for 'database'.
  ///
  /// Here, 'database' should be an open database, (see
  /// notmuch_database_open and notmuch_database_create).
  ///
  /// For the query string, we'll document the syntax here more
  /// completely in the future, but it's likely to be a specialized
  /// version of the general Xapian query syntax:
  ///
  /// https://xapian.org/docs/queryparser.html
  ///
  /// As a special case, passing either a length-zero string, (that is ""),
  /// or a string consisting of a single asterisk (that is "*"), will
  /// result in a query that returns all messages in the database.
  ///
  /// See notmuch_query_set_sort for controlling the order of results.
  /// See notmuch_query_search_messages and notmuch_query_search_threads
  /// to actually execute the query.
  ///
  /// User should call notmuch_query_destroy when finished with this
  /// query.
  ///
  /// Will return NULL if insufficient memory is available.
  ffi.Pointer<notmuch_query_t> notmuch_query_create(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> query_string,
  ) {
    return _notmuch_query_create(
      database,
      query_string,
    );
  }

  late final _notmuch_query_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_query_t> Function(ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_query_create');
  late final _notmuch_query_create = _notmuch_query_createPtr.asFunction<
      ffi.Pointer<notmuch_query_t> Function(
          ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>)>();

  int notmuch_query_create_with_syntax(
    ffi.Pointer<notmuch_database_t> database,
    ffi.Pointer<ffi.Int8> query_string,
    int syntax,
    ffi.Pointer<ffi.Pointer<notmuch_query_t>> output,
  ) {
    return _notmuch_query_create_with_syntax(
      database,
      query_string,
      syntax,
      output,
    );
  }

  late final _notmuch_query_create_with_syntaxPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Pointer<notmuch_query_t>>)>>(
      'notmuch_query_create_with_syntax');
  late final _notmuch_query_create_with_syntax =
      _notmuch_query_create_with_syntaxPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              int, ffi.Pointer<ffi.Pointer<notmuch_query_t>>)>();

  /// Return the query_string of this query. See notmuch_query_create.
  ffi.Pointer<ffi.Int8> notmuch_query_get_query_string(
    ffi.Pointer<notmuch_query_t> query,
  ) {
    return _notmuch_query_get_query_string(
      query,
    );
  }

  late final _notmuch_query_get_query_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_query_t>)>>('notmuch_query_get_query_string');
  late final _notmuch_query_get_query_string =
      _notmuch_query_get_query_stringPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_query_t>)>();

  /// Return the notmuch database of this query. See notmuch_query_create.
  ffi.Pointer<notmuch_database_t> notmuch_query_get_database(
    ffi.Pointer<notmuch_query_t> query,
  ) {
    return _notmuch_query_get_database(
      query,
    );
  }

  late final _notmuch_query_get_databasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_database_t> Function(
              ffi.Pointer<notmuch_query_t>)>>('notmuch_query_get_database');
  late final _notmuch_query_get_database =
      _notmuch_query_get_databasePtr.asFunction<
          ffi.Pointer<notmuch_database_t> Function(
              ffi.Pointer<notmuch_query_t>)>();

  /// Specify whether to omit excluded results or simply flag them.  By
  /// default, this is set to TRUE.
  ///
  /// If set to TRUE or ALL, notmuch_query_search_messages will omit excluded
  /// messages from the results, and notmuch_query_search_threads will omit
  /// threads that match only in excluded messages.  If set to TRUE,
  /// notmuch_query_search_threads will include all messages in threads that
  /// match in at least one non-excluded message.  Otherwise, if set to ALL,
  /// notmuch_query_search_threads will omit excluded messages from all threads.
  ///
  /// If set to FALSE or FLAG then both notmuch_query_search_messages and
  /// notmuch_query_search_threads will return all matching
  /// messages/threads regardless of exclude status. If set to FLAG then
  /// the exclude flag will be set for any excluded message that is
  /// returned by notmuch_query_search_messages, and the thread counts
  /// for threads returned by notmuch_query_search_threads will be the
  /// number of non-excluded messages/matches. Otherwise, if set to
  /// FALSE, then the exclude status is completely ignored.
  ///
  /// The performance difference when calling
  /// notmuch_query_search_messages should be relatively small (and both
  /// should be very fast).  However, in some cases,
  /// notmuch_query_search_threads is very much faster when omitting
  /// excluded messages as it does not need to construct the threads that
  /// only match in excluded messages.
  void notmuch_query_set_omit_excluded(
    ffi.Pointer<notmuch_query_t> query,
    int omit_excluded,
  ) {
    return _notmuch_query_set_omit_excluded(
      query,
      omit_excluded,
    );
  }

  late final _notmuch_query_set_omit_excludedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<notmuch_query_t>,
              ffi.Int32)>>('notmuch_query_set_omit_excluded');
  late final _notmuch_query_set_omit_excluded =
      _notmuch_query_set_omit_excludedPtr
          .asFunction<void Function(ffi.Pointer<notmuch_query_t>, int)>();

  /// Specify the sorting desired for this query.
  void notmuch_query_set_sort(
    ffi.Pointer<notmuch_query_t> query,
    int sort,
  ) {
    return _notmuch_query_set_sort(
      query,
      sort,
    );
  }

  late final _notmuch_query_set_sortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<notmuch_query_t>,
              ffi.Int32)>>('notmuch_query_set_sort');
  late final _notmuch_query_set_sort = _notmuch_query_set_sortPtr
      .asFunction<void Function(ffi.Pointer<notmuch_query_t>, int)>();

  /// Return the sort specified for this query. See
  /// notmuch_query_set_sort.
  int notmuch_query_get_sort(
    ffi.Pointer<notmuch_query_t> query,
  ) {
    return _notmuch_query_get_sort(
      query,
    );
  }

  late final _notmuch_query_get_sortPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<notmuch_query_t>)>>(
      'notmuch_query_get_sort');
  late final _notmuch_query_get_sort = _notmuch_query_get_sortPtr
      .asFunction<int Function(ffi.Pointer<notmuch_query_t>)>();

  /// Add a tag that will be excluded from the query results by default.
  /// This exclusion will be ignored if this tag appears explicitly in
  /// the query.
  ///
  /// @returns
  ///
  /// NOTMUCH_STATUS_SUCCESS: excluded was added successfully.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: a Xapian exception occurred.
  /// Most likely a problem lazily parsing the query string.
  ///
  /// NOTMUCH_STATUS_IGNORED: tag is explicitly present in the query, so
  /// not excluded.
  int notmuch_query_add_tag_exclude(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Int8> tag,
  ) {
    return _notmuch_query_add_tag_exclude(
      query,
      tag,
    );
  }

  late final _notmuch_query_add_tag_excludePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_query_add_tag_exclude');
  late final _notmuch_query_add_tag_exclude =
      _notmuch_query_add_tag_excludePtr.asFunction<
          int Function(ffi.Pointer<notmuch_query_t>, ffi.Pointer<ffi.Int8>)>();

  /// Execute a query for threads, returning a notmuch_threads_t object
  /// which can be used to iterate over the results. The returned threads
  /// object is owned by the query and as such, will only be valid until
  /// notmuch_query_destroy.
  ///
  /// Typical usage might be:
  ///
  /// notmuch_query_t *query;
  /// notmuch_threads_t *threads;
  /// notmuch_thread_t *thread;
  /// notmuch_status_t stat;
  ///
  /// query = notmuch_query_create (database, query_string);
  ///
  /// for (stat = notmuch_query_search_threads (query, &threads);
  /// stat == NOTMUCH_STATUS_SUCCESS &&
  /// notmuch_threads_valid (threads);
  /// notmuch_threads_move_to_next (threads))
  /// {
  /// thread = notmuch_threads_get (threads);
  /// ....
  /// notmuch_thread_destroy (thread);
  /// }
  ///
  /// notmuch_query_destroy (query);
  ///
  /// Note: If you are finished with a thread before its containing
  /// query, you can call notmuch_thread_destroy to clean up some memory
  /// sooner (as in the above example). Otherwise, if your thread objects
  /// are long-lived, then you don't need to call notmuch_thread_destroy
  /// and all the memory will still be reclaimed when the query is
  /// destroyed.
  ///
  /// Note that there's no explicit destructor needed for the
  /// notmuch_threads_t object. (For consistency, we do provide a
  /// notmuch_threads_destroy function, but there's no good reason
  /// to call it if the query is about to be destroyed).
  ///
  /// @since libnotmuch 5.0 (notmuch 0.25)
  int notmuch_query_search_threads(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Pointer<notmuch_threads_t>> out,
  ) {
    return _notmuch_query_search_threads(
      query,
      out,
    );
  }

  late final _notmuch_query_search_threadsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
                  ffi.Pointer<ffi.Pointer<notmuch_threads_t>>)>>(
      'notmuch_query_search_threads');
  late final _notmuch_query_search_threads =
      _notmuch_query_search_threadsPtr.asFunction<
          int Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Pointer<notmuch_threads_t>>)>();

  /// Deprecated alias for notmuch_query_search_threads.
  ///
  /// @deprecated Deprecated as of libnotmuch 5 (notmuch 0.25). Please
  /// use notmuch_query_search_threads instead.
  int notmuch_query_search_threads_st(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Pointer<notmuch_threads_t>> out,
  ) {
    return _notmuch_query_search_threads_st(
      query,
      out,
    );
  }

  late final _notmuch_query_search_threads_stPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
                  ffi.Pointer<ffi.Pointer<notmuch_threads_t>>)>>(
      'notmuch_query_search_threads_st');
  late final _notmuch_query_search_threads_st =
      _notmuch_query_search_threads_stPtr.asFunction<
          int Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Pointer<notmuch_threads_t>>)>();

  /// Execute a query for messages, returning a notmuch_messages_t object
  /// which can be used to iterate over the results. The returned
  /// messages object is owned by the query and as such, will only be
  /// valid until notmuch_query_destroy.
  ///
  /// Typical usage might be:
  ///
  /// notmuch_query_t *query;
  /// notmuch_messages_t *messages;
  /// notmuch_message_t *message;
  ///
  /// query = notmuch_query_create (database, query_string);
  ///
  /// for (messages = notmuch_query_search_messages (query);
  /// notmuch_messages_valid (messages);
  /// notmuch_messages_move_to_next (messages))
  /// {
  /// message = notmuch_messages_get (messages);
  /// ....
  /// notmuch_message_destroy (message);
  /// }
  ///
  /// notmuch_query_destroy (query);
  ///
  /// Note: If you are finished with a message before its containing
  /// query, you can call notmuch_message_destroy to clean up some memory
  /// sooner (as in the above example). Otherwise, if your message
  /// objects are long-lived, then you don't need to call
  /// notmuch_message_destroy and all the memory will still be reclaimed
  /// when the query is destroyed.
  ///
  /// Note that there's no explicit destructor needed for the
  /// notmuch_messages_t object. (For consistency, we do provide a
  /// notmuch_messages_destroy function, but there's no good
  /// reason to call it if the query is about to be destroyed).
  ///
  /// If a Xapian exception occurs this function will return NULL.
  ///
  /// @since libnotmuch 5 (notmuch 0.25)
  int notmuch_query_search_messages(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Pointer<notmuch_messages_t>> out,
  ) {
    return _notmuch_query_search_messages(
      query,
      out,
    );
  }

  late final _notmuch_query_search_messagesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
                  ffi.Pointer<ffi.Pointer<notmuch_messages_t>>)>>(
      'notmuch_query_search_messages');
  late final _notmuch_query_search_messages =
      _notmuch_query_search_messagesPtr.asFunction<
          int Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Pointer<notmuch_messages_t>>)>();

  /// Deprecated alias for notmuch_query_search_messages
  ///
  /// @deprecated Deprecated as of libnotmuch 5 (notmuch 0.25). Please use
  /// notmuch_query_search_messages instead.
  int notmuch_query_search_messages_st(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Pointer<notmuch_messages_t>> out,
  ) {
    return _notmuch_query_search_messages_st(
      query,
      out,
    );
  }

  late final _notmuch_query_search_messages_stPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
                  ffi.Pointer<ffi.Pointer<notmuch_messages_t>>)>>(
      'notmuch_query_search_messages_st');
  late final _notmuch_query_search_messages_st =
      _notmuch_query_search_messages_stPtr.asFunction<
          int Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Pointer<notmuch_messages_t>>)>();

  /// Destroy a notmuch_query_t along with any associated resources.
  ///
  /// This will in turn destroy any notmuch_threads_t and
  /// notmuch_messages_t objects generated by this query, (and in
  /// turn any notmuch_thread_t and notmuch_message_t objects generated
  /// from those results, etc.), if such objects haven't already been
  /// destroyed.
  void notmuch_query_destroy(
    ffi.Pointer<notmuch_query_t> query,
  ) {
    return _notmuch_query_destroy(
      query,
    );
  }

  late final _notmuch_query_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<notmuch_query_t>)>>(
      'notmuch_query_destroy');
  late final _notmuch_query_destroy = _notmuch_query_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_query_t>)>();

  /// Is the given 'threads' iterator pointing at a valid thread.
  ///
  /// When this function returns TRUE, notmuch_threads_get will return a
  /// valid object. Whereas when this function returns FALSE,
  /// notmuch_threads_get will return NULL.
  ///
  /// If passed a NULL pointer, this function returns FALSE
  ///
  /// See the documentation of notmuch_query_search_threads for example
  /// code showing how to iterate over a notmuch_threads_t object.
  int notmuch_threads_valid(
    ffi.Pointer<notmuch_threads_t> threads,
  ) {
    return _notmuch_threads_valid(
      threads,
    );
  }

  late final _notmuch_threads_validPtr = _lookup<
      ffi.NativeFunction<
          notmuch_bool_t Function(
              ffi.Pointer<notmuch_threads_t>)>>('notmuch_threads_valid');
  late final _notmuch_threads_valid = _notmuch_threads_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_threads_t>)>();

  /// Get the current thread from 'threads' as a notmuch_thread_t.
  ///
  /// Note: The returned thread belongs to 'threads' and has a lifetime
  /// identical to it (and the query to which it belongs).
  ///
  /// See the documentation of notmuch_query_search_threads for example
  /// code showing how to iterate over a notmuch_threads_t object.
  ///
  /// If an out-of-memory situation occurs, this function will return
  /// NULL.
  ffi.Pointer<notmuch_thread_t> notmuch_threads_get(
    ffi.Pointer<notmuch_threads_t> threads,
  ) {
    return _notmuch_threads_get(
      threads,
    );
  }

  late final _notmuch_threads_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_thread_t> Function(
              ffi.Pointer<notmuch_threads_t>)>>('notmuch_threads_get');
  late final _notmuch_threads_get = _notmuch_threads_getPtr.asFunction<
      ffi.Pointer<notmuch_thread_t> Function(ffi.Pointer<notmuch_threads_t>)>();

  /// Move the 'threads' iterator to the next thread.
  ///
  /// If 'threads' is already pointing at the last thread then the
  /// iterator will be moved to a point just beyond that last thread,
  /// (where notmuch_threads_valid will return FALSE and
  /// notmuch_threads_get will return NULL).
  ///
  /// See the documentation of notmuch_query_search_threads for example
  /// code showing how to iterate over a notmuch_threads_t object.
  void notmuch_threads_move_to_next(
    ffi.Pointer<notmuch_threads_t> threads,
  ) {
    return _notmuch_threads_move_to_next(
      threads,
    );
  }

  late final _notmuch_threads_move_to_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_threads_t>)>>('notmuch_threads_move_to_next');
  late final _notmuch_threads_move_to_next = _notmuch_threads_move_to_nextPtr
      .asFunction<void Function(ffi.Pointer<notmuch_threads_t>)>();

  /// Destroy a notmuch_threads_t object.
  ///
  /// It's not strictly necessary to call this function. All memory from
  /// the notmuch_threads_t object will be reclaimed when the
  /// containing query object is destroyed.
  void notmuch_threads_destroy(
    ffi.Pointer<notmuch_threads_t> threads,
  ) {
    return _notmuch_threads_destroy(
      threads,
    );
  }

  late final _notmuch_threads_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_threads_t>)>>('notmuch_threads_destroy');
  late final _notmuch_threads_destroy = _notmuch_threads_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_threads_t>)>();

  /// Return the number of messages matching a search.
  ///
  /// This function performs a search and returns the number of matching
  /// messages.
  ///
  /// @returns
  ///
  /// NOTMUCH_STATUS_SUCCESS: query completed successfully.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: a Xapian exception occurred. The
  /// value of *count is not defined.
  ///
  /// @since libnotmuch 5 (notmuch 0.25)
  int notmuch_query_count_messages(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _notmuch_query_count_messages(
      query,
      count,
    );
  }

  late final _notmuch_query_count_messagesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Uint32>)>>('notmuch_query_count_messages');
  late final _notmuch_query_count_messages =
      _notmuch_query_count_messagesPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_query_t>, ffi.Pointer<ffi.Uint32>)>();

  /// Deprecated alias for notmuch_query_count_messages
  ///
  ///
  /// @deprecated Deprecated since libnotmuch 5.0 (notmuch 0.25). Please
  /// use notmuch_query_count_messages instead.
  int notmuch_query_count_messages_st(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _notmuch_query_count_messages_st(
      query,
      count,
    );
  }

  late final _notmuch_query_count_messages_stPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Uint32>)>>('notmuch_query_count_messages_st');
  late final _notmuch_query_count_messages_st =
      _notmuch_query_count_messages_stPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_query_t>, ffi.Pointer<ffi.Uint32>)>();

  /// Return the number of threads matching a search.
  ///
  /// This function performs a search and returns the number of unique thread IDs
  /// in the matching messages. This is the same as number of threads matching a
  /// search.
  ///
  /// Note that this is a significantly heavier operation than
  /// notmuch_query_count_messages{_st}().
  ///
  /// @returns
  ///
  /// NOTMUCH_STATUS_OUT_OF_MEMORY: Memory allocation failed. The value
  /// of *count is not defined
  ///
  /// NOTMUCH_STATUS_SUCCESS: query completed successfully.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: a Xapian exception occurred. The
  /// value of *count is not defined.
  ///
  /// @since libnotmuch 5 (notmuch 0.25)
  int notmuch_query_count_threads(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _notmuch_query_count_threads(
      query,
      count,
    );
  }

  late final _notmuch_query_count_threadsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Uint32>)>>('notmuch_query_count_threads');
  late final _notmuch_query_count_threads =
      _notmuch_query_count_threadsPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_query_t>, ffi.Pointer<ffi.Uint32>)>();

  /// Deprecated alias for notmuch_query_count_threads
  ///
  /// @deprecated Deprecated as of libnotmuch 5.0 (notmuch 0.25). Please
  /// use notmuch_query_count_threads_st instead.
  int notmuch_query_count_threads_st(
    ffi.Pointer<notmuch_query_t> query,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _notmuch_query_count_threads_st(
      query,
      count,
    );
  }

  late final _notmuch_query_count_threads_stPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_query_t>,
              ffi.Pointer<ffi.Uint32>)>>('notmuch_query_count_threads_st');
  late final _notmuch_query_count_threads_st =
      _notmuch_query_count_threads_stPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_query_t>, ffi.Pointer<ffi.Uint32>)>();

  /// Get the thread ID of 'thread'.
  ///
  /// The returned string belongs to 'thread' and as such, should not be
  /// modified by the caller and will only be valid for as long as the
  /// thread is valid, (which is until notmuch_thread_destroy or until
  /// the query from which it derived is destroyed).
  ffi.Pointer<ffi.Int8> notmuch_thread_get_thread_id(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_thread_id(
      thread,
    );
  }

  late final _notmuch_thread_get_thread_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_thread_t>)>>('notmuch_thread_get_thread_id');
  late final _notmuch_thread_get_thread_id =
      _notmuch_thread_get_thread_idPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the total number of messages in 'thread'.
  ///
  /// This count consists of all messages in the database belonging to
  /// this thread. Contrast with notmuch_thread_get_matched_messages() .
  int notmuch_thread_get_total_messages(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_total_messages(
      thread,
    );
  }

  late final _notmuch_thread_get_total_messagesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_get_total_messages');
  late final _notmuch_thread_get_total_messages =
      _notmuch_thread_get_total_messagesPtr
          .asFunction<int Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the total number of files in 'thread'.
  ///
  /// This sums notmuch_message_count_files over all messages in the
  /// thread
  /// @returns Non-negative integer
  /// @since libnotmuch 5.0 (notmuch 0.25)
  int notmuch_thread_get_total_files(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_total_files(
      thread,
    );
  }

  late final _notmuch_thread_get_total_filesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_get_total_files');
  late final _notmuch_thread_get_total_files =
      _notmuch_thread_get_total_filesPtr
          .asFunction<int Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get a notmuch_messages_t iterator for the top-level messages in
  /// 'thread' in oldest-first order.
  ///
  /// This iterator will not necessarily iterate over all of the messages
  /// in the thread. It will only iterate over the messages in the thread
  /// which are not replies to other messages in the thread.
  ///
  /// The returned list will be destroyed when the thread is destroyed.
  ffi.Pointer<notmuch_messages_t> notmuch_thread_get_toplevel_messages(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_toplevel_messages(
      thread,
    );
  }

  late final _notmuch_thread_get_toplevel_messagesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_messages_t> Function(
                  ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_get_toplevel_messages');
  late final _notmuch_thread_get_toplevel_messages =
      _notmuch_thread_get_toplevel_messagesPtr.asFunction<
          ffi.Pointer<notmuch_messages_t> Function(
              ffi.Pointer<notmuch_thread_t>)>();

  /// Get a notmuch_thread_t iterator for all messages in 'thread' in
  /// oldest-first order.
  ///
  /// The returned list will be destroyed when the thread is destroyed.
  ffi.Pointer<notmuch_messages_t> notmuch_thread_get_messages(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_messages(
      thread,
    );
  }

  late final _notmuch_thread_get_messagesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_messages_t> Function(
              ffi.Pointer<notmuch_thread_t>)>>('notmuch_thread_get_messages');
  late final _notmuch_thread_get_messages =
      _notmuch_thread_get_messagesPtr.asFunction<
          ffi.Pointer<notmuch_messages_t> Function(
              ffi.Pointer<notmuch_thread_t>)>();

  /// Get the number of messages in 'thread' that matched the search.
  ///
  /// This count includes only the messages in this thread that were
  /// matched by the search from which the thread was created and were
  /// not excluded by any exclude tags passed in with the query (see
  /// notmuch_query_add_tag_exclude). Contrast with
  /// notmuch_thread_get_total_messages() .
  int notmuch_thread_get_matched_messages(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_matched_messages(
      thread,
    );
  }

  late final _notmuch_thread_get_matched_messagesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_get_matched_messages');
  late final _notmuch_thread_get_matched_messages =
      _notmuch_thread_get_matched_messagesPtr
          .asFunction<int Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the authors of 'thread' as a UTF-8 string.
  ///
  /// The returned string is a comma-separated list of the names of the
  /// authors of mail messages in the query results that belong to this
  /// thread.
  ///
  /// The string contains authors of messages matching the query first, then
  /// non-matched authors (with the two groups separated by '|'). Within
  /// each group, authors are ordered by date.
  ///
  /// The returned string belongs to 'thread' and as such, should not be
  /// modified by the caller and will only be valid for as long as the
  /// thread is valid, (which is until notmuch_thread_destroy or until
  /// the query from which it derived is destroyed).
  ffi.Pointer<ffi.Int8> notmuch_thread_get_authors(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_authors(
      thread,
    );
  }

  late final _notmuch_thread_get_authorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_thread_t>)>>('notmuch_thread_get_authors');
  late final _notmuch_thread_get_authors =
      _notmuch_thread_get_authorsPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the subject of 'thread' as a UTF-8 string.
  ///
  /// The subject is taken from the first message (according to the query
  /// order---see notmuch_query_set_sort) in the query results that
  /// belongs to this thread.
  ///
  /// The returned string belongs to 'thread' and as such, should not be
  /// modified by the caller and will only be valid for as long as the
  /// thread is valid, (which is until notmuch_thread_destroy or until
  /// the query from which it derived is destroyed).
  ffi.Pointer<ffi.Int8> notmuch_thread_get_subject(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_subject(
      thread,
    );
  }

  late final _notmuch_thread_get_subjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_thread_t>)>>('notmuch_thread_get_subject');
  late final _notmuch_thread_get_subject =
      _notmuch_thread_get_subjectPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the date of the oldest message in 'thread' as a time_t value.
  int notmuch_thread_get_oldest_date(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_oldest_date(
      thread,
    );
  }

  late final _notmuch_thread_get_oldest_datePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_get_oldest_date');
  late final _notmuch_thread_get_oldest_date =
      _notmuch_thread_get_oldest_datePtr
          .asFunction<int Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the date of the newest message in 'thread' as a time_t value.
  int notmuch_thread_get_newest_date(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_newest_date(
      thread,
    );
  }

  late final _notmuch_thread_get_newest_datePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_get_newest_date');
  late final _notmuch_thread_get_newest_date =
      _notmuch_thread_get_newest_datePtr
          .asFunction<int Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Get the tags for 'thread', returning a notmuch_tags_t object which
  /// can be used to iterate over all tags.
  ///
  /// Note: In the Notmuch database, tags are stored on individual
  /// messages, not on threads. So the tags returned here will be all
  /// tags of the messages which matched the search and which belong to
  /// this thread.
  ///
  /// The tags object is owned by the thread and as such, will only be
  /// valid for as long as the thread is valid, (for example, until
  /// notmuch_thread_destroy or until the query from which it derived is
  /// destroyed).
  ///
  /// Typical usage might be:
  ///
  /// notmuch_thread_t *thread;
  /// notmuch_tags_t *tags;
  /// const char *tag;
  ///
  /// thread = notmuch_threads_get (threads);
  ///
  /// for (tags = notmuch_thread_get_tags (thread);
  /// notmuch_tags_valid (tags);
  /// notmuch_tags_move_to_next (tags))
  /// {
  /// tag = notmuch_tags_get (tags);
  /// ....
  /// }
  ///
  /// notmuch_thread_destroy (thread);
  ///
  /// Note that there's no explicit destructor needed for the
  /// notmuch_tags_t object. (For consistency, we do provide a
  /// notmuch_tags_destroy function, but there's no good reason to call
  /// it if the message is about to be destroyed).
  ffi.Pointer<notmuch_tags_t> notmuch_thread_get_tags(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_get_tags(
      thread,
    );
  }

  late final _notmuch_thread_get_tagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_tags_t> Function(
              ffi.Pointer<notmuch_thread_t>)>>('notmuch_thread_get_tags');
  late final _notmuch_thread_get_tags = _notmuch_thread_get_tagsPtr.asFunction<
      ffi.Pointer<notmuch_tags_t> Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Destroy a notmuch_thread_t object.
  void notmuch_thread_destroy(
    ffi.Pointer<notmuch_thread_t> thread,
  ) {
    return _notmuch_thread_destroy(
      thread,
    );
  }

  late final _notmuch_thread_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<notmuch_thread_t>)>>(
      'notmuch_thread_destroy');
  late final _notmuch_thread_destroy = _notmuch_thread_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_thread_t>)>();

  /// Is the given 'messages' iterator pointing at a valid message.
  ///
  /// When this function returns TRUE, notmuch_messages_get will return a
  /// valid object. Whereas when this function returns FALSE,
  /// notmuch_messages_get will return NULL.
  ///
  /// See the documentation of notmuch_query_search_messages for example
  /// code showing how to iterate over a notmuch_messages_t object.
  int notmuch_messages_valid(
    ffi.Pointer<notmuch_messages_t> messages,
  ) {
    return _notmuch_messages_valid(
      messages,
    );
  }

  late final _notmuch_messages_validPtr = _lookup<
      ffi.NativeFunction<
          notmuch_bool_t Function(
              ffi.Pointer<notmuch_messages_t>)>>('notmuch_messages_valid');
  late final _notmuch_messages_valid = _notmuch_messages_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_messages_t>)>();

  /// Get the current message from 'messages' as a notmuch_message_t.
  ///
  /// Note: The returned message belongs to 'messages' and has a lifetime
  /// identical to it (and the query to which it belongs).
  ///
  /// See the documentation of notmuch_query_search_messages for example
  /// code showing how to iterate over a notmuch_messages_t object.
  ///
  /// If an out-of-memory situation occurs, this function will return
  /// NULL.
  ffi.Pointer<notmuch_message_t> notmuch_messages_get(
    ffi.Pointer<notmuch_messages_t> messages,
  ) {
    return _notmuch_messages_get(
      messages,
    );
  }

  late final _notmuch_messages_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_message_t> Function(
              ffi.Pointer<notmuch_messages_t>)>>('notmuch_messages_get');
  late final _notmuch_messages_get = _notmuch_messages_getPtr.asFunction<
      ffi.Pointer<notmuch_message_t> Function(
          ffi.Pointer<notmuch_messages_t>)>();

  /// Move the 'messages' iterator to the next message.
  ///
  /// If 'messages' is already pointing at the last message then the
  /// iterator will be moved to a point just beyond that last message,
  /// (where notmuch_messages_valid will return FALSE and
  /// notmuch_messages_get will return NULL).
  ///
  /// See the documentation of notmuch_query_search_messages for example
  /// code showing how to iterate over a notmuch_messages_t object.
  void notmuch_messages_move_to_next(
    ffi.Pointer<notmuch_messages_t> messages,
  ) {
    return _notmuch_messages_move_to_next(
      messages,
    );
  }

  late final _notmuch_messages_move_to_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_messages_t>)>>(
      'notmuch_messages_move_to_next');
  late final _notmuch_messages_move_to_next = _notmuch_messages_move_to_nextPtr
      .asFunction<void Function(ffi.Pointer<notmuch_messages_t>)>();

  /// Destroy a notmuch_messages_t object.
  ///
  /// It's not strictly necessary to call this function. All memory from
  /// the notmuch_messages_t object will be reclaimed when the containing
  /// query object is destroyed.
  void notmuch_messages_destroy(
    ffi.Pointer<notmuch_messages_t> messages,
  ) {
    return _notmuch_messages_destroy(
      messages,
    );
  }

  late final _notmuch_messages_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_messages_t>)>>('notmuch_messages_destroy');
  late final _notmuch_messages_destroy = _notmuch_messages_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_messages_t>)>();

  /// Return a list of tags from all messages.
  ///
  /// The resulting list is guaranteed not to contain duplicated tags.
  ///
  /// WARNING: You can no longer iterate over messages after calling this
  /// function, because the iterator will point at the end of the list.
  /// We do not have a function to reset the iterator yet and the only
  /// way how you can iterate over the list again is to recreate the
  /// message list.
  ///
  /// The function returns NULL on error.
  ffi.Pointer<notmuch_tags_t> notmuch_messages_collect_tags(
    ffi.Pointer<notmuch_messages_t> messages,
  ) {
    return _notmuch_messages_collect_tags(
      messages,
    );
  }

  late final _notmuch_messages_collect_tagsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_tags_t> Function(
                  ffi.Pointer<notmuch_messages_t>)>>(
      'notmuch_messages_collect_tags');
  late final _notmuch_messages_collect_tags =
      _notmuch_messages_collect_tagsPtr.asFunction<
          ffi.Pointer<notmuch_tags_t> Function(
              ffi.Pointer<notmuch_messages_t>)>();

  /// Get the database associated with this message.
  ///
  /// @since libnotmuch 5.2 (notmuch 0.27)
  ffi.Pointer<notmuch_database_t> notmuch_message_get_database(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_database(
      message,
    );
  }

  late final _notmuch_message_get_databasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_database_t> Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_get_database');
  late final _notmuch_message_get_database =
      _notmuch_message_get_databasePtr.asFunction<
          ffi.Pointer<notmuch_database_t> Function(
              ffi.Pointer<notmuch_message_t>)>();

  /// Get the message ID of 'message'.
  ///
  /// The returned string belongs to 'message' and as such, should not be
  /// modified by the caller and will only be valid for as long as the
  /// message is valid, (which is until the query from which it derived
  /// is destroyed).
  ///
  /// This function will return NULL if triggers an unhandled Xapian
  /// exception.
  ffi.Pointer<ffi.Int8> notmuch_message_get_message_id(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_message_id(
      message,
    );
  }

  late final _notmuch_message_get_message_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_message_t>)>>(
      'notmuch_message_get_message_id');
  late final _notmuch_message_get_message_id =
      _notmuch_message_get_message_idPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_message_t>)>();

  /// Get the thread ID of 'message'.
  ///
  /// The returned string belongs to 'message' and as such, should not be
  /// modified by the caller and will only be valid for as long as the
  /// message is valid, (for example, until the user calls
  /// notmuch_message_destroy on 'message' or until a query from which it
  /// derived is destroyed).
  ///
  /// This function will return NULL if triggers an unhandled Xapian
  /// exception.
  ffi.Pointer<ffi.Int8> notmuch_message_get_thread_id(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_thread_id(
      message,
    );
  }

  late final _notmuch_message_get_thread_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_message_t>)>>(
      'notmuch_message_get_thread_id');
  late final _notmuch_message_get_thread_id =
      _notmuch_message_get_thread_idPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_message_t>)>();

  /// Get a notmuch_messages_t iterator for all of the replies to
  /// 'message'.
  ///
  /// Note: This call only makes sense if 'message' was ultimately
  /// obtained from a notmuch_thread_t object, (such as by coming
  /// directly from the result of calling notmuch_thread_get_
  /// toplevel_messages or by any number of subsequent
  /// calls to notmuch_message_get_replies).
  ///
  /// If 'message' was obtained through some non-thread means, (such as
  /// by a call to notmuch_query_search_messages), then this function
  /// will return NULL.
  ///
  /// If there are no replies to 'message', this function will return
  /// NULL. (Note that notmuch_messages_valid will accept that NULL
  /// value as legitimate, and simply return FALSE for it.)
  ///
  /// This function also returns NULL if it triggers a Xapian exception.
  ///
  /// The returned list will be destroyed when the thread is
  /// destroyed.
  ffi.Pointer<notmuch_messages_t> notmuch_message_get_replies(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_replies(
      message,
    );
  }

  late final _notmuch_message_get_repliesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_messages_t> Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_get_replies');
  late final _notmuch_message_get_replies =
      _notmuch_message_get_repliesPtr.asFunction<
          ffi.Pointer<notmuch_messages_t> Function(
              ffi.Pointer<notmuch_message_t>)>();

  /// Get the total number of files associated with a message.
  /// @returns Non-negative integer for file count.
  /// @returns Negative integer for error.
  /// @since libnotmuch 5.0 (notmuch 0.25)
  int notmuch_message_count_files(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_count_files(
      message,
    );
  }

  late final _notmuch_message_count_filesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_count_files');
  late final _notmuch_message_count_files = _notmuch_message_count_filesPtr
      .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// Get a filename for the email corresponding to 'message'.
  ///
  /// The returned filename is an absolute filename, (the initial
  /// component will match notmuch_database_get_path() ).
  ///
  /// The returned string belongs to the message so should not be
  /// modified or freed by the caller (nor should it be referenced after
  /// the message is destroyed).
  ///
  /// Note: If this message corresponds to multiple files in the mail
  /// store, (that is, multiple files contain identical message IDs),
  /// this function will arbitrarily return a single one of those
  /// filenames. See notmuch_message_get_filenames for returning the
  /// complete list of filenames.
  ///
  /// This function returns NULL if it triggers a Xapian exception.
  ffi.Pointer<ffi.Int8> notmuch_message_get_filename(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_filename(
      message,
    );
  }

  late final _notmuch_message_get_filenamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_get_filename');
  late final _notmuch_message_get_filename =
      _notmuch_message_get_filenamePtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_message_t>)>();

  /// Get all filenames for the email corresponding to 'message'.
  ///
  /// Returns a notmuch_filenames_t iterator listing all the filenames
  /// associated with 'message'. These files may not have identical
  /// content, but each will have the identical Message-ID.
  ///
  /// Each filename in the iterator is an absolute filename, (the initial
  /// component will match notmuch_database_get_path() ).
  ///
  /// This function returns NULL if it triggers a Xapian exception.
  ffi.Pointer<notmuch_filenames_t> notmuch_message_get_filenames(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_filenames(
      message,
    );
  }

  late final _notmuch_message_get_filenamesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_filenames_t> Function(
                  ffi.Pointer<notmuch_message_t>)>>(
      'notmuch_message_get_filenames');
  late final _notmuch_message_get_filenames =
      _notmuch_message_get_filenamesPtr.asFunction<
          ffi.Pointer<notmuch_filenames_t> Function(
              ffi.Pointer<notmuch_message_t>)>();

  /// Re-index the e-mail corresponding to 'message' using the supplied index options
  ///
  /// Returns the status of the re-index operation.  (see the return
  /// codes documented in notmuch_database_index_file)
  ///
  /// After reindexing, the user should discard the message object passed
  /// in here by calling notmuch_message_destroy, since it refers to the
  /// original message, not to the reindexed message.
  int notmuch_message_reindex(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<notmuch_indexopts_t> indexopts,
  ) {
    return _notmuch_message_reindex(
      message,
      indexopts,
    );
  }

  late final _notmuch_message_reindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<notmuch_indexopts_t>)>>('notmuch_message_reindex');
  late final _notmuch_message_reindex = _notmuch_message_reindexPtr.asFunction<
      int Function(
          ffi.Pointer<notmuch_message_t>, ffi.Pointer<notmuch_indexopts_t>)>();

  /// Get a value of a flag for the email corresponding to 'message'.
  ///
  /// returns FALSE in case of errors.
  ///
  /// @deprecated Deprecated as of libnotmuch 5.3 (notmuch 0.31). Please
  /// use notmuch_message_get_flag_st instead.
  int notmuch_message_get_flag(
    ffi.Pointer<notmuch_message_t> message,
    int flag,
  ) {
    return _notmuch_message_get_flag(
      message,
      flag,
    );
  }

  late final _notmuch_message_get_flagPtr = _lookup<
      ffi.NativeFunction<
          notmuch_bool_t Function(ffi.Pointer<notmuch_message_t>,
              ffi.Int32)>>('notmuch_message_get_flag');
  late final _notmuch_message_get_flag = _notmuch_message_get_flagPtr
      .asFunction<int Function(ffi.Pointer<notmuch_message_t>, int)>();

  /// Get a value of a flag for the email corresponding to 'message'.
  ///
  /// @param message a message object
  /// @param flag flag to check
  /// @param is_set pointer to boolean to store flag value.
  ///
  /// @retval #NOTMUCH_STATUS_SUCCESS
  /// @retval #NOTMUCH_STATUS_NULL_POINTER is_set is NULL
  /// @retval #NOTMUCH_STATUS_XAPIAN_EXCEPTION Accessing the database
  /// triggered an exception.
  ///
  /// @since libnotmuch 5.3 (notmuch 0.31)
  int notmuch_message_get_flag_st(
    ffi.Pointer<notmuch_message_t> message,
    int flag,
    ffi.Pointer<notmuch_bool_t> is_set,
  ) {
    return _notmuch_message_get_flag_st(
      message,
      flag,
      is_set,
    );
  }

  late final _notmuch_message_get_flag_stPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_message_t>, ffi.Int32,
              ffi.Pointer<notmuch_bool_t>)>>('notmuch_message_get_flag_st');
  late final _notmuch_message_get_flag_st =
      _notmuch_message_get_flag_stPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_t>, int,
              ffi.Pointer<notmuch_bool_t>)>();

  /// Set a value of a flag for the email corresponding to 'message'.
  void notmuch_message_set_flag(
    ffi.Pointer<notmuch_message_t> message,
    int flag,
    int value,
  ) {
    return _notmuch_message_set_flag(
      message,
      flag,
      value,
    );
  }

  late final _notmuch_message_set_flagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<notmuch_message_t>, ffi.Int32,
              notmuch_bool_t)>>('notmuch_message_set_flag');
  late final _notmuch_message_set_flag = _notmuch_message_set_flagPtr
      .asFunction<void Function(ffi.Pointer<notmuch_message_t>, int, int)>();

  /// Get the date of 'message' as a time_t value.
  ///
  /// For the original textual representation of the Date header from the
  /// message call notmuch_message_get_header() with a header value of
  /// "date".
  ///
  /// Returns 0 in case of error.
  int notmuch_message_get_date(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_date(
      message,
    );
  }

  late final _notmuch_message_get_datePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_get_date');
  late final _notmuch_message_get_date = _notmuch_message_get_datePtr
      .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// Get the value of the specified header from 'message' as a UTF-8 string.
  ///
  /// Common headers are stored in the database when the message is
  /// indexed and will be returned from the database.  Other headers will
  /// be read from the actual message file.
  ///
  /// The header name is case insensitive.
  ///
  /// The returned string belongs to the message so should not be
  /// modified or freed by the caller (nor should it be referenced after
  /// the message is destroyed).
  ///
  /// Returns an empty string ("") if the message does not contain a
  /// header line matching 'header'. Returns NULL if any error occurs.
  ffi.Pointer<ffi.Int8> notmuch_message_get_header(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> header,
  ) {
    return _notmuch_message_get_header(
      message,
      header,
    );
  }

  late final _notmuch_message_get_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_message_get_header');
  late final _notmuch_message_get_header =
      _notmuch_message_get_headerPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>)>();

  /// Get the tags for 'message', returning a notmuch_tags_t object which
  /// can be used to iterate over all tags.
  ///
  /// The tags object is owned by the message and as such, will only be
  /// valid for as long as the message is valid, (which is until the
  /// query from which it derived is destroyed).
  ///
  /// Typical usage might be:
  ///
  /// notmuch_message_t *message;
  /// notmuch_tags_t *tags;
  /// const char *tag;
  ///
  /// message = notmuch_database_find_message (database, message_id);
  ///
  /// for (tags = notmuch_message_get_tags (message);
  /// notmuch_tags_valid (tags);
  /// notmuch_tags_move_to_next (tags))
  /// {
  /// tag = notmuch_tags_get (tags);
  /// ....
  /// }
  ///
  /// notmuch_message_destroy (message);
  ///
  /// Note that there's no explicit destructor needed for the
  /// notmuch_tags_t object. (For consistency, we do provide a
  /// notmuch_tags_destroy function, but there's no good reason to call
  /// it if the message is about to be destroyed).
  ffi.Pointer<notmuch_tags_t> notmuch_message_get_tags(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_get_tags(
      message,
    );
  }

  late final _notmuch_message_get_tagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_tags_t> Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_get_tags');
  late final _notmuch_message_get_tags =
      _notmuch_message_get_tagsPtr.asFunction<
          ffi.Pointer<notmuch_tags_t> Function(
              ffi.Pointer<notmuch_message_t>)>();

  /// Add a tag to the given message.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Tag successfully added to message
  ///
  /// NOTMUCH_STATUS_NULL_POINTER: The 'tag' argument is NULL
  ///
  /// NOTMUCH_STATUS_TAG_TOO_LONG: The length of 'tag' is too long
  /// (exceeds NOTMUCH_TAG_MAX)
  ///
  /// NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only
  /// mode so message cannot be modified.
  int notmuch_message_add_tag(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> tag,
  ) {
    return _notmuch_message_add_tag(
      message,
      tag,
    );
  }

  late final _notmuch_message_add_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_message_add_tag');
  late final _notmuch_message_add_tag = _notmuch_message_add_tagPtr.asFunction<
      int Function(ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>)>();

  /// Remove a tag from the given message.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Tag successfully removed from message
  ///
  /// NOTMUCH_STATUS_NULL_POINTER: The 'tag' argument is NULL
  ///
  /// NOTMUCH_STATUS_TAG_TOO_LONG: The length of 'tag' is too long
  /// (exceeds NOTMUCH_TAG_MAX)
  ///
  /// NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only
  /// mode so message cannot be modified.
  int notmuch_message_remove_tag(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> tag,
  ) {
    return _notmuch_message_remove_tag(
      message,
      tag,
    );
  }

  late final _notmuch_message_remove_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_message_remove_tag');
  late final _notmuch_message_remove_tag =
      _notmuch_message_remove_tagPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>)>();

  /// Remove all tags from the given message.
  ///
  /// See notmuch_message_freeze for an example showing how to safely
  /// replace tag values.
  ///
  /// @retval #NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in
  /// read-only mode so message cannot be modified.
  /// @retval #NOTMUCH_STATUS_XAPIAN_EXCEPTION: an exception was thrown
  /// accessing the database.
  int notmuch_message_remove_all_tags(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_remove_all_tags(
      message,
    );
  }

  late final _notmuch_message_remove_all_tagsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_message_t>)>>(
      'notmuch_message_remove_all_tags');
  late final _notmuch_message_remove_all_tags =
      _notmuch_message_remove_all_tagsPtr
          .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// Add/remove tags according to maildir flags in the message filename(s).
  ///
  /// This function examines the filenames of 'message' for maildir
  /// flags, and adds or removes tags on 'message' as follows when these
  /// flags are present:
  ///
  /// Flag	Action if present
  /// ----	-----------------
  /// 'D'	Adds the "draft" tag to the message
  /// 'F'	Adds the "flagged" tag to the message
  /// 'P'	Adds the "passed" tag to the message
  /// 'R'	Adds the "replied" tag to the message
  /// 'S'	Removes the "unread" tag from the message
  ///
  /// For each flag that is not present, the opposite action (add/remove)
  /// is performed for the corresponding tags.
  ///
  /// Flags are identified as trailing components of the filename after a
  /// sequence of ":2,".
  ///
  /// If there are multiple filenames associated with this message, the
  /// flag is considered present if it appears in one or more
  /// filenames. (That is, the flags from the multiple filenames are
  /// combined with the logical OR operator.)
  ///
  /// A client can ensure that notmuch database tags remain synchronized
  /// with maildir flags by calling this function after each call to
  /// notmuch_database_index_file. See also
  /// notmuch_message_tags_to_maildir_flags for synchronizing tag changes
  /// back to maildir flags.
  int notmuch_message_maildir_flags_to_tags(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_maildir_flags_to_tags(
      message,
    );
  }

  late final _notmuch_message_maildir_flags_to_tagsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_message_t>)>>(
      'notmuch_message_maildir_flags_to_tags');
  late final _notmuch_message_maildir_flags_to_tags =
      _notmuch_message_maildir_flags_to_tagsPtr
          .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// return TRUE if any filename of 'message' has maildir flag 'flag',
  /// FALSE otherwise.
  ///
  /// Deprecated wrapper for notmuch_message_has_maildir_flag_st
  ///
  /// @returns FALSE in case of error
  /// @deprecated libnotmuch 5.3 (notmuch 0.31)
  int notmuch_message_has_maildir_flag(
    ffi.Pointer<notmuch_message_t> message,
    int flag,
  ) {
    return _notmuch_message_has_maildir_flag(
      message,
      flag,
    );
  }

  late final _notmuch_message_has_maildir_flagPtr = _lookup<
      ffi.NativeFunction<
          notmuch_bool_t Function(ffi.Pointer<notmuch_message_t>,
              ffi.Int8)>>('notmuch_message_has_maildir_flag');
  late final _notmuch_message_has_maildir_flag =
      _notmuch_message_has_maildir_flagPtr
          .asFunction<int Function(ffi.Pointer<notmuch_message_t>, int)>();

  /// check message for maildir flag
  ///
  /// @param [in,out]	message message to check
  /// @param [in] flag	flag to check for
  /// @param [out] is_set  pointer to boolean
  ///
  /// @retval #NOTMUCH_STATUS_SUCCESS
  /// @retval #NOTMUCH_STATUS_NULL_POINTER is_set is NULL
  /// @retval #NOTMUCH_STATUS_XAPIAN_EXCEPTION Accessing the database
  /// triggered an exception.
  int notmuch_message_has_maildir_flag_st(
    ffi.Pointer<notmuch_message_t> message,
    int flag,
    ffi.Pointer<notmuch_bool_t> is_set,
  ) {
    return _notmuch_message_has_maildir_flag_st(
      message,
      flag,
      is_set,
    );
  }

  late final _notmuch_message_has_maildir_flag_stPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_message_t>, ffi.Int8,
                  ffi.Pointer<notmuch_bool_t>)>>(
      'notmuch_message_has_maildir_flag_st');
  late final _notmuch_message_has_maildir_flag_st =
      _notmuch_message_has_maildir_flag_stPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_t>, int,
              ffi.Pointer<notmuch_bool_t>)>();

  /// Rename message filename(s) to encode tags as maildir flags.
  ///
  /// Specifically, for each filename corresponding to this message:
  ///
  /// If the filename is not in a maildir directory, do nothing.  (A
  /// maildir directory is determined as a directory named "new" or
  /// "cur".) Similarly, if the filename has invalid maildir info,
  /// (repeated or outof-ASCII-order flag characters after ":2,"), then
  /// do nothing.
  ///
  /// If the filename is in a maildir directory, rename the file so that
  /// its filename ends with the sequence ":2," followed by zero or more
  /// of the following single-character flags (in ASCII order):
  ///
  /// * flag 'D' iff the message has the "draft" tag
  /// * flag 'F' iff the message has the "flagged" tag
  /// * flag 'P' iff the message has the "passed" tag
  /// * flag 'R' iff the message has the "replied" tag
  /// * flag 'S' iff the message does not have the "unread" tag
  ///
  /// Any existing flags unmentioned in the list above will be preserved
  /// in the renaming.
  ///
  /// Also, if this filename is in a directory named "new", rename it to
  /// be within the neighboring directory named "cur".
  ///
  /// A client can ensure that maildir filename flags remain synchronized
  /// with notmuch database tags by calling this function after changing
  /// tags, (after calls to notmuch_message_add_tag,
  /// notmuch_message_remove_tag, or notmuch_message_freeze/
  /// notmuch_message_thaw). See also notmuch_message_maildir_flags_to_tags
  /// for synchronizing maildir flag changes back to tags.
  int notmuch_message_tags_to_maildir_flags(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_tags_to_maildir_flags(
      message,
    );
  }

  late final _notmuch_message_tags_to_maildir_flagsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_message_t>)>>(
      'notmuch_message_tags_to_maildir_flags');
  late final _notmuch_message_tags_to_maildir_flags =
      _notmuch_message_tags_to_maildir_flagsPtr
          .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// Freeze the current state of 'message' within the database.
  ///
  /// This means that changes to the message state, (via
  /// notmuch_message_add_tag, notmuch_message_remove_tag, and
  /// notmuch_message_remove_all_tags), will not be committed to the
  /// database until the message is thawed with notmuch_message_thaw.
  ///
  /// Multiple calls to freeze/thaw are valid and these calls will
  /// "stack". That is there must be as many calls to thaw as to freeze
  /// before a message is actually thawed.
  ///
  /// The ability to do freeze/thaw allows for safe transactions to
  /// change tag values. For example, explicitly setting a message to
  /// have a given set of tags might look like this:
  ///
  /// notmuch_message_freeze (message);
  ///
  /// notmuch_message_remove_all_tags (message);
  ///
  /// for (i = 0; i < NUM_TAGS; i++)
  /// notmuch_message_add_tag (message, tags[i]);
  ///
  /// notmuch_message_thaw (message);
  ///
  /// With freeze/thaw used like this, the message in the database is
  /// guaranteed to have either the full set of original tag values, or
  /// the full set of new tag values, but nothing in between.
  ///
  /// Imagine the example above without freeze/thaw and the operation
  /// somehow getting interrupted. This could result in the message being
  /// left with no tags if the interruption happened after
  /// notmuch_message_remove_all_tags but before notmuch_message_add_tag.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Message successfully frozen.
  ///
  /// NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only
  /// mode so message cannot be modified.
  int notmuch_message_freeze(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_freeze(
      message,
    );
  }

  late final _notmuch_message_freezePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_freeze');
  late final _notmuch_message_freeze = _notmuch_message_freezePtr
      .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// Thaw the current 'message', synchronizing any changes that may have
  /// occurred while 'message' was frozen into the notmuch database.
  ///
  /// See notmuch_message_freeze for an example of how to use this
  /// function to safely provide tag changes.
  ///
  /// Multiple calls to freeze/thaw are valid and these calls with
  /// "stack". That is there must be as many calls to thaw as to freeze
  /// before a message is actually thawed.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: Message successfully thawed, (or at least
  /// its frozen count has successfully been reduced by 1).
  ///
  /// NOTMUCH_STATUS_UNBALANCED_FREEZE_THAW: An attempt was made to thaw
  /// an unfrozen message. That is, there have been an unbalanced
  /// number of calls to notmuch_message_freeze and
  /// notmuch_message_thaw.
  int notmuch_message_thaw(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_thaw(
      message,
    );
  }

  late final _notmuch_message_thawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_thaw');
  late final _notmuch_message_thaw = _notmuch_message_thawPtr
      .asFunction<int Function(ffi.Pointer<notmuch_message_t>)>();

  /// Destroy a notmuch_message_t object.
  ///
  /// It can be useful to call this function in the case of a single
  /// query object with many messages in the result, (such as iterating
  /// over the entire database). Otherwise, it's fine to never call this
  /// function and there will still be no memory leaks. (The memory from
  /// the messages get reclaimed when the containing query is destroyed.)
  void notmuch_message_destroy(
    ffi.Pointer<notmuch_message_t> message,
  ) {
    return _notmuch_message_destroy(
      message,
    );
  }

  late final _notmuch_message_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_message_t>)>>('notmuch_message_destroy');
  late final _notmuch_message_destroy = _notmuch_message_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_message_t>)>();

  /// @name Message Properties
  ///
  /// This interface provides the ability to attach arbitrary (key,value)
  /// string pairs to a message, to remove such pairs, and to iterate
  /// over them.  The caller should take some care as to what keys they
  /// add or delete values for, as other subsystems or extensions may
  /// depend on these properties.
  ///
  /// Please see notmuch-properties(7) for more details about specific
  /// properties and conventions around their use.
  ///
  /// /
  /// /**@{*/
  /// /**
  /// Retrieve the value for a single property key
  ///
  /// *value* is set to a string owned by the message or NULL if there is
  /// no such key. In the case of multiple values for the given key, the
  /// first one is retrieved.
  ///
  /// @returns
  /// - NOTMUCH_STATUS_NULL_POINTER: *value* may not be NULL.
  /// - NOTMUCH_STATUS_SUCCESS: No error occurred.
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_message_get_property(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> value,
  ) {
    return _notmuch_message_get_property(
      message,
      key,
      value,
    );
  }

  late final _notmuch_message_get_propertyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_message_t>,
                  ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_message_get_property');
  late final _notmuch_message_get_property =
      _notmuch_message_get_propertyPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Add a (key,value) pair to a message
  ///
  /// @returns
  /// - NOTMUCH_STATUS_ILLEGAL_ARGUMENT: *key* may not contain an '=' character.
  /// - NOTMUCH_STATUS_NULL_POINTER: Neither *key* nor *value* may be NULL.
  /// - NOTMUCH_STATUS_SUCCESS: No error occurred.
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_message_add_property(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _notmuch_message_add_property(
      message,
      key,
      value,
    );
  }

  late final _notmuch_message_add_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_message_add_property');
  late final _notmuch_message_add_property =
      _notmuch_message_add_propertyPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>();

  /// Remove a (key,value) pair from a message.
  ///
  /// It is not an error to remove a non-existent (key,value) pair
  ///
  /// @returns
  /// - NOTMUCH_STATUS_ILLEGAL_ARGUMENT: *key* may not contain an '=' character.
  /// - NOTMUCH_STATUS_NULL_POINTER: Neither *key* nor *value* may be NULL.
  /// - NOTMUCH_STATUS_SUCCESS: No error occurred.
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_message_remove_property(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _notmuch_message_remove_property(
      message,
      key,
      value,
    );
  }

  late final _notmuch_message_remove_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_message_remove_property');
  late final _notmuch_message_remove_property =
      _notmuch_message_remove_propertyPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>();

  /// Remove all (key,value) pairs from the given message.
  ///
  /// @param[in,out] message  message to operate on.
  /// @param[in]     key      key to delete properties for. If NULL, delete
  /// properties for all keys
  /// @returns
  /// - NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in
  /// read-only mode so message cannot be modified.
  /// - NOTMUCH_STATUS_SUCCESS: No error occurred.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_message_remove_all_properties(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _notmuch_message_remove_all_properties(
      message,
      key,
    );
  }

  late final _notmuch_message_remove_all_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_message_remove_all_properties');
  late final _notmuch_message_remove_all_properties =
      _notmuch_message_remove_all_propertiesPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>)>();

  /// Remove all (prefix*,value) pairs from the given message
  ///
  /// @param[in,out] message  message to operate on.
  /// @param[in]     prefix   delete properties with keys that start with prefix.
  /// If NULL, delete all properties
  /// @returns
  /// - NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in
  /// read-only mode so message cannot be modified.
  /// - NOTMUCH_STATUS_SUCCESS: No error occurred.
  ///
  /// @since libnotmuch 5.1 (notmuch 0.26)
  int notmuch_message_remove_all_properties_with_prefix(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> prefix,
  ) {
    return _notmuch_message_remove_all_properties_with_prefix(
      message,
      prefix,
    );
  }

  late final _notmuch_message_remove_all_properties_with_prefixPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>)>>(
      'notmuch_message_remove_all_properties_with_prefix');
  late final _notmuch_message_remove_all_properties_with_prefix =
      _notmuch_message_remove_all_properties_with_prefixPtr.asFunction<
          int Function(
              ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>)>();

  /// Get the properties for *message*, returning a
  /// notmuch_message_properties_t object which can be used to iterate
  /// over all properties.
  ///
  /// The notmuch_message_properties_t object is owned by the message and
  /// as such, will only be valid for as long as the message is valid,
  /// (which is until the query from which it derived is destroyed).
  ///
  /// @param[in] message  The message to examine
  /// @param[in] key      key or key prefix
  /// @param[in] exact    if TRUE, require exact match with key. Otherwise
  /// treat as prefix.
  ///
  /// Typical usage might be:
  ///
  /// notmuch_message_properties_t *list;
  ///
  /// for (list = notmuch_message_get_properties (message, "testkey1", TRUE);
  /// notmuch_message_properties_valid (list); notmuch_message_properties_move_to_next (list)) {
  /// printf("%s\n", notmuch_message_properties_value(list));
  /// }
  ///
  /// notmuch_message_properties_destroy (list);
  ///
  /// Note that there's no explicit destructor needed for the
  /// notmuch_message_properties_t object. (For consistency, we do
  /// provide a notmuch_message_properities_destroy function, but there's
  /// no good reason to call it if the message is about to be destroyed).
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  ffi.Pointer<notmuch_message_properties_t> notmuch_message_get_properties(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> key,
    int exact,
  ) {
    return _notmuch_message_get_properties(
      message,
      key,
      exact,
    );
  }

  late final _notmuch_message_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_message_properties_t> Function(
              ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>,
              notmuch_bool_t)>>('notmuch_message_get_properties');
  late final _notmuch_message_get_properties =
      _notmuch_message_get_propertiesPtr.asFunction<
          ffi.Pointer<notmuch_message_properties_t> Function(
              ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>, int)>();

  /// Return the number of properties named "key" belonging to the specific message.
  ///
  /// @param[in] message  The message to examine
  /// @param[in] key      key to count
  /// @param[out] count   The number of matching properties associated with this message.
  ///
  /// @returns
  ///
  /// NOTMUCH_STATUS_SUCCESS: successful count, possibly some other error.
  ///
  /// @since libnotmuch 5.2 (notmuch 0.27)
  int notmuch_message_count_properties(
    ffi.Pointer<notmuch_message_t> message,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _notmuch_message_count_properties(
      message,
      key,
      count,
    );
  }

  late final _notmuch_message_count_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_message_t>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>>('notmuch_message_count_properties');
  late final _notmuch_message_count_properties =
      _notmuch_message_count_propertiesPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>();

  /// Is the given *properties* iterator pointing at a valid (key,value)
  /// pair.
  ///
  /// When this function returns TRUE,
  /// notmuch_message_properties_{key,value} will return a valid string,
  /// and notmuch_message_properties_move_to_next will do what it
  /// says. Whereas when this function returns FALSE, calling any of
  /// these functions results in undefined behaviour.
  ///
  /// See the documentation of notmuch_message_get_properties for example
  /// code showing how to iterate over a notmuch_message_properties_t
  /// object.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_message_properties_valid(
    ffi.Pointer<notmuch_message_properties_t> properties,
  ) {
    return _notmuch_message_properties_valid(
      properties,
    );
  }

  late final _notmuch_message_properties_validPtr = _lookup<
          ffi.NativeFunction<
              notmuch_bool_t Function(
                  ffi.Pointer<notmuch_message_properties_t>)>>(
      'notmuch_message_properties_valid');
  late final _notmuch_message_properties_valid =
      _notmuch_message_properties_validPtr.asFunction<
          int Function(ffi.Pointer<notmuch_message_properties_t>)>();

  /// Move the *properties* iterator to the next (key,value) pair
  ///
  /// If *properties* is already pointing at the last pair then the iterator
  /// will be moved to a point just beyond that last pair, (where
  /// notmuch_message_properties_valid will return FALSE).
  ///
  /// See the documentation of notmuch_message_get_properties for example
  /// code showing how to iterate over a notmuch_message_properties_t object.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  void notmuch_message_properties_move_to_next(
    ffi.Pointer<notmuch_message_properties_t> properties,
  ) {
    return _notmuch_message_properties_move_to_next(
      properties,
    );
  }

  late final _notmuch_message_properties_move_to_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_message_properties_t>)>>(
      'notmuch_message_properties_move_to_next');
  late final _notmuch_message_properties_move_to_next =
      _notmuch_message_properties_move_to_nextPtr.asFunction<
          void Function(ffi.Pointer<notmuch_message_properties_t>)>();

  /// Return the key from the current (key,value) pair.
  ///
  /// this could be useful if iterating for a prefix
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  ffi.Pointer<ffi.Int8> notmuch_message_properties_key(
    ffi.Pointer<notmuch_message_properties_t> properties,
  ) {
    return _notmuch_message_properties_key(
      properties,
    );
  }

  late final _notmuch_message_properties_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<notmuch_message_properties_t>)>>(
      'notmuch_message_properties_key');
  late final _notmuch_message_properties_key =
      _notmuch_message_properties_keyPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_message_properties_t>)>();

  /// Return the value from the current (key,value) pair.
  ///
  /// This could be useful if iterating for a prefix.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  ffi.Pointer<ffi.Int8> notmuch_message_properties_value(
    ffi.Pointer<notmuch_message_properties_t> properties,
  ) {
    return _notmuch_message_properties_value(
      properties,
    );
  }

  late final _notmuch_message_properties_valuePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<notmuch_message_properties_t>)>>(
      'notmuch_message_properties_value');
  late final _notmuch_message_properties_value =
      _notmuch_message_properties_valuePtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_message_properties_t>)>();

  /// Destroy a notmuch_message_properties_t object.
  ///
  /// It's not strictly necessary to call this function. All memory from
  /// the notmuch_message_properties_t object will be reclaimed when the
  /// containing message object is destroyed.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  void notmuch_message_properties_destroy(
    ffi.Pointer<notmuch_message_properties_t> properties,
  ) {
    return _notmuch_message_properties_destroy(
      properties,
    );
  }

  late final _notmuch_message_properties_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_message_properties_t>)>>(
      'notmuch_message_properties_destroy');
  late final _notmuch_message_properties_destroy =
      _notmuch_message_properties_destroyPtr.asFunction<
          void Function(ffi.Pointer<notmuch_message_properties_t>)>();

  /// Is the given 'tags' iterator pointing at a valid tag.
  ///
  /// When this function returns TRUE, notmuch_tags_get will return a
  /// valid string. Whereas when this function returns FALSE,
  /// notmuch_tags_get will return NULL.
  ///
  /// See the documentation of notmuch_message_get_tags for example code
  /// showing how to iterate over a notmuch_tags_t object.
  int notmuch_tags_valid(
    ffi.Pointer<notmuch_tags_t> tags,
  ) {
    return _notmuch_tags_valid(
      tags,
    );
  }

  late final _notmuch_tags_validPtr = _lookup<
      ffi.NativeFunction<
          notmuch_bool_t Function(
              ffi.Pointer<notmuch_tags_t>)>>('notmuch_tags_valid');
  late final _notmuch_tags_valid = _notmuch_tags_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_tags_t>)>();

  /// Get the current tag from 'tags' as a string.
  ///
  /// Note: The returned string belongs to 'tags' and has a lifetime
  /// identical to it (and the query to which it ultimately belongs).
  ///
  /// See the documentation of notmuch_message_get_tags for example code
  /// showing how to iterate over a notmuch_tags_t object.
  ffi.Pointer<ffi.Int8> notmuch_tags_get(
    ffi.Pointer<notmuch_tags_t> tags,
  ) {
    return _notmuch_tags_get(
      tags,
    );
  }

  late final _notmuch_tags_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_tags_t>)>>('notmuch_tags_get');
  late final _notmuch_tags_get = _notmuch_tags_getPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_tags_t>)>();

  /// Move the 'tags' iterator to the next tag.
  ///
  /// If 'tags' is already pointing at the last tag then the iterator
  /// will be moved to a point just beyond that last tag, (where
  /// notmuch_tags_valid will return FALSE and notmuch_tags_get will
  /// return NULL).
  ///
  /// See the documentation of notmuch_message_get_tags for example code
  /// showing how to iterate over a notmuch_tags_t object.
  void notmuch_tags_move_to_next(
    ffi.Pointer<notmuch_tags_t> tags,
  ) {
    return _notmuch_tags_move_to_next(
      tags,
    );
  }

  late final _notmuch_tags_move_to_nextPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<notmuch_tags_t>)>>(
      'notmuch_tags_move_to_next');
  late final _notmuch_tags_move_to_next = _notmuch_tags_move_to_nextPtr
      .asFunction<void Function(ffi.Pointer<notmuch_tags_t>)>();

  /// Destroy a notmuch_tags_t object.
  ///
  /// It's not strictly necessary to call this function. All memory from
  /// the notmuch_tags_t object will be reclaimed when the containing
  /// message or query objects are destroyed.
  void notmuch_tags_destroy(
    ffi.Pointer<notmuch_tags_t> tags,
  ) {
    return _notmuch_tags_destroy(
      tags,
    );
  }

  late final _notmuch_tags_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<notmuch_tags_t>)>>(
      'notmuch_tags_destroy');
  late final _notmuch_tags_destroy = _notmuch_tags_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_tags_t>)>();

  /// Store an mtime within the database for 'directory'.
  ///
  /// The 'directory' should be an object retrieved from the database
  /// with notmuch_database_get_directory for a particular path.
  ///
  /// The intention is for the caller to use the mtime to allow efficient
  /// identification of new messages to be added to the database. The
  /// recommended usage is as follows:
  ///
  /// o Read the mtime of a directory from the filesystem
  ///
  /// o Call index_file for all mail files in the directory
  ///
  /// o Call notmuch_directory_set_mtime with the mtime read from the
  /// filesystem.
  ///
  /// Then, when wanting to check for updates to the directory in the
  /// future, the client can call notmuch_directory_get_mtime and know
  /// that it only needs to add files if the mtime of the directory and
  /// files are newer than the stored timestamp.
  ///
  /// Note: The notmuch_directory_get_mtime function does not allow the
  /// caller to distinguish a timestamp of 0 from a non-existent
  /// timestamp. So don't store a timestamp of 0 unless you are
  /// comfortable with that.
  ///
  /// Return value:
  ///
  /// NOTMUCH_STATUS_SUCCESS: mtime successfully stored in database.
  ///
  /// NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception
  /// occurred, mtime not stored.
  ///
  /// NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only
  /// mode so directory mtime cannot be modified.
  int notmuch_directory_set_mtime(
    ffi.Pointer<notmuch_directory_t> directory,
    int mtime,
  ) {
    return _notmuch_directory_set_mtime(
      directory,
      mtime,
    );
  }

  late final _notmuch_directory_set_mtimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_directory_t>,
              ffi.Int32)>>('notmuch_directory_set_mtime');
  late final _notmuch_directory_set_mtime = _notmuch_directory_set_mtimePtr
      .asFunction<int Function(ffi.Pointer<notmuch_directory_t>, int)>();

  /// Get the mtime of a directory, (as previously stored with
  /// notmuch_directory_set_mtime).
  ///
  /// Returns 0 if no mtime has previously been stored for this
  /// directory.
  int notmuch_directory_get_mtime(
    ffi.Pointer<notmuch_directory_t> directory,
  ) {
    return _notmuch_directory_get_mtime(
      directory,
    );
  }

  late final _notmuch_directory_get_mtimePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_directory_t>)>>(
      'notmuch_directory_get_mtime');
  late final _notmuch_directory_get_mtime = _notmuch_directory_get_mtimePtr
      .asFunction<int Function(ffi.Pointer<notmuch_directory_t>)>();

  /// Get a notmuch_filenames_t iterator listing all the filenames of
  /// messages in the database within the given directory.
  ///
  /// The returned filenames will be the basename-entries only (not
  /// complete paths).
  ///
  /// Returns NULL if it triggers a Xapian exception
  ffi.Pointer<notmuch_filenames_t> notmuch_directory_get_child_files(
    ffi.Pointer<notmuch_directory_t> directory,
  ) {
    return _notmuch_directory_get_child_files(
      directory,
    );
  }

  late final _notmuch_directory_get_child_filesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_filenames_t> Function(
                  ffi.Pointer<notmuch_directory_t>)>>(
      'notmuch_directory_get_child_files');
  late final _notmuch_directory_get_child_files =
      _notmuch_directory_get_child_filesPtr.asFunction<
          ffi.Pointer<notmuch_filenames_t> Function(
              ffi.Pointer<notmuch_directory_t>)>();

  /// Get a notmuch_filenames_t iterator listing all the filenames of
  /// sub-directories in the database within the given directory.
  ///
  /// The returned filenames will be the basename-entries only (not
  /// complete paths).
  ///
  /// Returns NULL if it triggers a Xapian exception
  ffi.Pointer<notmuch_filenames_t> notmuch_directory_get_child_directories(
    ffi.Pointer<notmuch_directory_t> directory,
  ) {
    return _notmuch_directory_get_child_directories(
      directory,
    );
  }

  late final _notmuch_directory_get_child_directoriesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_filenames_t> Function(
                  ffi.Pointer<notmuch_directory_t>)>>(
      'notmuch_directory_get_child_directories');
  late final _notmuch_directory_get_child_directories =
      _notmuch_directory_get_child_directoriesPtr.asFunction<
          ffi.Pointer<notmuch_filenames_t> Function(
              ffi.Pointer<notmuch_directory_t>)>();

  /// Delete directory document from the database, and destroy the
  /// notmuch_directory_t object. Assumes any child directories and files
  /// have been deleted by the caller.
  ///
  /// @since libnotmuch 4.3 (notmuch 0.21)
  int notmuch_directory_delete(
    ffi.Pointer<notmuch_directory_t> directory,
  ) {
    return _notmuch_directory_delete(
      directory,
    );
  }

  late final _notmuch_directory_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_directory_t>)>>('notmuch_directory_delete');
  late final _notmuch_directory_delete = _notmuch_directory_deletePtr
      .asFunction<int Function(ffi.Pointer<notmuch_directory_t>)>();

  /// Destroy a notmuch_directory_t object.
  void notmuch_directory_destroy(
    ffi.Pointer<notmuch_directory_t> directory,
  ) {
    return _notmuch_directory_destroy(
      directory,
    );
  }

  late final _notmuch_directory_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_directory_t>)>>('notmuch_directory_destroy');
  late final _notmuch_directory_destroy = _notmuch_directory_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_directory_t>)>();

  /// Is the given 'filenames' iterator pointing at a valid filename.
  ///
  /// When this function returns TRUE, notmuch_filenames_get will return
  /// a valid string. Whereas when this function returns FALSE,
  /// notmuch_filenames_get will return NULL.
  ///
  /// It is acceptable to pass NULL for 'filenames', in which case this
  /// function will always return FALSE.
  int notmuch_filenames_valid(
    ffi.Pointer<notmuch_filenames_t> filenames,
  ) {
    return _notmuch_filenames_valid(
      filenames,
    );
  }

  late final _notmuch_filenames_validPtr = _lookup<
      ffi.NativeFunction<
          notmuch_bool_t Function(
              ffi.Pointer<notmuch_filenames_t>)>>('notmuch_filenames_valid');
  late final _notmuch_filenames_valid = _notmuch_filenames_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_filenames_t>)>();

  /// Get the current filename from 'filenames' as a string.
  ///
  /// Note: The returned string belongs to 'filenames' and has a lifetime
  /// identical to it (and the directory to which it ultimately belongs).
  ///
  /// It is acceptable to pass NULL for 'filenames', in which case this
  /// function will always return NULL.
  ffi.Pointer<ffi.Int8> notmuch_filenames_get(
    ffi.Pointer<notmuch_filenames_t> filenames,
  ) {
    return _notmuch_filenames_get(
      filenames,
    );
  }

  late final _notmuch_filenames_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_filenames_t>)>>('notmuch_filenames_get');
  late final _notmuch_filenames_get = _notmuch_filenames_getPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_filenames_t>)>();

  /// Move the 'filenames' iterator to the next filename.
  ///
  /// If 'filenames' is already pointing at the last filename then the
  /// iterator will be moved to a point just beyond that last filename,
  /// (where notmuch_filenames_valid will return FALSE and
  /// notmuch_filenames_get will return NULL).
  ///
  /// It is acceptable to pass NULL for 'filenames', in which case this
  /// function will do nothing.
  void notmuch_filenames_move_to_next(
    ffi.Pointer<notmuch_filenames_t> filenames,
  ) {
    return _notmuch_filenames_move_to_next(
      filenames,
    );
  }

  late final _notmuch_filenames_move_to_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_filenames_t>)>>(
      'notmuch_filenames_move_to_next');
  late final _notmuch_filenames_move_to_next =
      _notmuch_filenames_move_to_nextPtr
          .asFunction<void Function(ffi.Pointer<notmuch_filenames_t>)>();

  /// Destroy a notmuch_filenames_t object.
  ///
  /// It's not strictly necessary to call this function. All memory from
  /// the notmuch_filenames_t object will be reclaimed when the
  /// containing directory object is destroyed.
  ///
  /// It is acceptable to pass NULL for 'filenames', in which case this
  /// function will do nothing.
  void notmuch_filenames_destroy(
    ffi.Pointer<notmuch_filenames_t> filenames,
  ) {
    return _notmuch_filenames_destroy(
      filenames,
    );
  }

  late final _notmuch_filenames_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_filenames_t>)>>('notmuch_filenames_destroy');
  late final _notmuch_filenames_destroy = _notmuch_filenames_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_filenames_t>)>();

  /// set config 'key' to 'value'
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  /// @retval #NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in
  /// read-only mode so message cannot be modified.
  /// @retval #NOTMUCH_STATUS_XAPIAN_EXCEPTION: an exception was thrown
  /// accessing the database.
  /// @retval #NOTMUCH_STATUS_SUCCESS
  int notmuch_database_set_config(
    ffi.Pointer<notmuch_database_t> db,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _notmuch_database_set_config(
      db,
      key,
      value,
    );
  }

  late final _notmuch_database_set_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_database_set_config');
  late final _notmuch_database_set_config =
      _notmuch_database_set_configPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>();

  /// retrieve config item 'key', assign to  'value'
  ///
  /// keys which have not been previously set with n_d_set_config will
  /// return an empty string.
  ///
  /// return value is allocated by malloc and should be freed by the
  /// caller.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_database_get_config(
    ffi.Pointer<notmuch_database_t> db,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> value,
  ) {
    return _notmuch_database_get_config(
      db,
      key,
      value,
    );
  }

  late final _notmuch_database_get_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'notmuch_database_get_config');
  late final _notmuch_database_get_config =
      _notmuch_database_get_configPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Create an iterator for all config items with keys matching a given prefix
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_database_get_config_list(
    ffi.Pointer<notmuch_database_t> db,
    ffi.Pointer<ffi.Int8> prefix,
    ffi.Pointer<ffi.Pointer<notmuch_config_list_t>> out,
  ) {
    return _notmuch_database_get_config_list(
      db,
      prefix,
      out,
    );
  }

  late final _notmuch_database_get_config_listPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<notmuch_database_t>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<notmuch_config_list_t>>)>>(
      'notmuch_database_get_config_list');
  late final _notmuch_database_get_config_list =
      _notmuch_database_get_config_listPtr.asFunction<
          int Function(ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<notmuch_config_list_t>>)>();

  /// Is 'config_list' iterator valid (i.e. _key, _value, _move_to_next can be called).
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_config_list_valid(
    ffi.Pointer<notmuch_config_list_t> config_list,
  ) {
    return _notmuch_config_list_valid(
      config_list,
    );
  }

  late final _notmuch_config_list_validPtr = _lookup<
          ffi.NativeFunction<
              notmuch_bool_t Function(ffi.Pointer<notmuch_config_list_t>)>>(
      'notmuch_config_list_valid');
  late final _notmuch_config_list_valid = _notmuch_config_list_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_config_list_t>)>();

  /// return key for current config pair
  ///
  /// return value is owned by the iterator, and will be destroyed by the
  /// next call to notmuch_config_list_key or notmuch_config_list_destroy.
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  ffi.Pointer<ffi.Int8> notmuch_config_list_key(
    ffi.Pointer<notmuch_config_list_t> config_list,
  ) {
    return _notmuch_config_list_key(
      config_list,
    );
  }

  late final _notmuch_config_list_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_config_list_t>)>>('notmuch_config_list_key');
  late final _notmuch_config_list_key = _notmuch_config_list_keyPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_config_list_t>)>();

  /// return 'value' for current config pair
  ///
  /// return value is owned by the iterator, and will be destroyed by the
  /// next call to notmuch_config_list_value or notmuch config_list_destroy
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  /// @retval NULL for errors
  ffi.Pointer<ffi.Int8> notmuch_config_list_value(
    ffi.Pointer<notmuch_config_list_t> config_list,
  ) {
    return _notmuch_config_list_value(
      config_list,
    );
  }

  late final _notmuch_config_list_valuePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<notmuch_config_list_t>)>>(
      'notmuch_config_list_value');
  late final _notmuch_config_list_value =
      _notmuch_config_list_valuePtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_config_list_t>)>();

  /// move 'config_list' iterator to the next pair
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  void notmuch_config_list_move_to_next(
    ffi.Pointer<notmuch_config_list_t> config_list,
  ) {
    return _notmuch_config_list_move_to_next(
      config_list,
    );
  }

  late final _notmuch_config_list_move_to_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_list_t>)>>(
      'notmuch_config_list_move_to_next');
  late final _notmuch_config_list_move_to_next =
      _notmuch_config_list_move_to_nextPtr
          .asFunction<void Function(ffi.Pointer<notmuch_config_list_t>)>();

  /// free any resources held by 'config_list'
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  void notmuch_config_list_destroy(
    ffi.Pointer<notmuch_config_list_t> config_list,
  ) {
    return _notmuch_config_list_destroy(
      config_list,
    );
  }

  late final _notmuch_config_list_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_list_t>)>>(
      'notmuch_config_list_destroy');
  late final _notmuch_config_list_destroy = _notmuch_config_list_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_config_list_t>)>();

  /// get a configuration value from an open database.
  ///
  /// This value reflects all configuration information given at the time
  /// the database was opened.
  ///
  /// @param[in] notmuch database
  /// @param[in] key configuration key
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval NULL if 'key' unknown or if no value is known for
  /// 'key'.  Otherwise returns a string owned by notmuch which should
  /// not be modified nor freed by the caller.
  ffi.Pointer<ffi.Int8> notmuch_config_get(
    ffi.Pointer<notmuch_database_t> notmuch,
    int key,
  ) {
    return _notmuch_config_get(
      notmuch,
      key,
    );
  }

  late final _notmuch_config_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_database_t>,
              ffi.Int32)>>('notmuch_config_get');
  late final _notmuch_config_get = _notmuch_config_getPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_database_t>, int)>();

  /// set a configuration value from in an open database.
  ///
  /// This value reflects all configuration information given at the time
  /// the database was opened.
  ///
  /// @param[in,out] notmuch database open read/write
  /// @param[in] key configuration key
  /// @param[in] val configuration value
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval returns any return value for notmuch_database_set_config.
  int notmuch_config_set(
    ffi.Pointer<notmuch_database_t> notmuch,
    int key,
    ffi.Pointer<ffi.Int8> val,
  ) {
    return _notmuch_config_set(
      notmuch,
      key,
      val,
    );
  }

  late final _notmuch_config_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_database_t>, ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('notmuch_config_set');
  late final _notmuch_config_set = _notmuch_config_setPtr.asFunction<
      int Function(
          ffi.Pointer<notmuch_database_t>, int, ffi.Pointer<ffi.Int8>)>();

  /// Returns an iterator for a ';'-delimited list of configuration values
  ///
  /// These values reflect all configuration information given at the
  /// time the database was opened.
  ///
  /// @param[in] notmuch database
  /// @param[in] key configuration key
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval NULL in case of error.
  ffi.Pointer<notmuch_config_values_t> notmuch_config_get_values(
    ffi.Pointer<notmuch_database_t> notmuch,
    int key,
  ) {
    return _notmuch_config_get_values(
      notmuch,
      key,
    );
  }

  late final _notmuch_config_get_valuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_config_values_t> Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Int32)>>('notmuch_config_get_values');
  late final _notmuch_config_get_values =
      _notmuch_config_get_valuesPtr.asFunction<
          ffi.Pointer<notmuch_config_values_t> Function(
              ffi.Pointer<notmuch_database_t>, int)>();

  /// Returns an iterator for a ';'-delimited list of configuration values
  ///
  /// These values reflect all configuration information given at the
  /// time the database was opened.
  ///
  /// @param[in] notmuch database
  /// @param[in] key configuration key
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval NULL in case of error.
  ffi.Pointer<notmuch_config_values_t> notmuch_config_get_values_string(
    ffi.Pointer<notmuch_database_t> notmuch,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _notmuch_config_get_values_string(
      notmuch,
      key,
    );
  }

  late final _notmuch_config_get_values_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_config_values_t> Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_config_get_values_string');
  late final _notmuch_config_get_values_string =
      _notmuch_config_get_values_stringPtr.asFunction<
          ffi.Pointer<notmuch_config_values_t> Function(
              ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>)>();

  /// Is the given 'config_values' iterator pointing at a valid element.
  ///
  /// @param[in] values iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval FALSE if passed a NULL pointer, or the iterator is exhausted.
  int notmuch_config_values_valid(
    ffi.Pointer<notmuch_config_values_t> values,
  ) {
    return _notmuch_config_values_valid(
      values,
    );
  }

  late final _notmuch_config_values_validPtr = _lookup<
          ffi.NativeFunction<
              notmuch_bool_t Function(ffi.Pointer<notmuch_config_values_t>)>>(
      'notmuch_config_values_valid');
  late final _notmuch_config_values_valid = _notmuch_config_values_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_config_values_t>)>();

  /// Get the current value from the 'values' iterator
  ///
  /// @param[in] values iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval a string with the same lifetime as the iterator
  ffi.Pointer<ffi.Int8> notmuch_config_values_get(
    ffi.Pointer<notmuch_config_values_t> values,
  ) {
    return _notmuch_config_values_get(
      values,
    );
  }

  late final _notmuch_config_values_getPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<notmuch_config_values_t>)>>(
      'notmuch_config_values_get');
  late final _notmuch_config_values_get =
      _notmuch_config_values_getPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_config_values_t>)>();

  /// Move the 'values' iterator to the next element
  ///
  /// @param[in,out] values iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  void notmuch_config_values_move_to_next(
    ffi.Pointer<notmuch_config_values_t> values,
  ) {
    return _notmuch_config_values_move_to_next(
      values,
    );
  }

  late final _notmuch_config_values_move_to_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_values_t>)>>(
      'notmuch_config_values_move_to_next');
  late final _notmuch_config_values_move_to_next =
      _notmuch_config_values_move_to_nextPtr
          .asFunction<void Function(ffi.Pointer<notmuch_config_values_t>)>();

  /// reset the 'values' iterator to the first element
  ///
  /// @param[in,out] values iterator. A NULL value is ignored.
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  void notmuch_config_values_start(
    ffi.Pointer<notmuch_config_values_t> values,
  ) {
    return _notmuch_config_values_start(
      values,
    );
  }

  late final _notmuch_config_values_startPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_values_t>)>>(
      'notmuch_config_values_start');
  late final _notmuch_config_values_start = _notmuch_config_values_startPtr
      .asFunction<void Function(ffi.Pointer<notmuch_config_values_t>)>();

  /// Destroy a config values iterator, along with any associated
  /// resources.
  ///
  /// @param[in,out] values iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  void notmuch_config_values_destroy(
    ffi.Pointer<notmuch_config_values_t> values,
  ) {
    return _notmuch_config_values_destroy(
      values,
    );
  }

  late final _notmuch_config_values_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_values_t>)>>(
      'notmuch_config_values_destroy');
  late final _notmuch_config_values_destroy = _notmuch_config_values_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_config_values_t>)>();

  /// Returns an iterator for a (key, value) configuration pairs
  ///
  /// @param[in] notmuch database
  /// @param[in] prefix prefix for keys. Pass "" for all keys.
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval NULL in case of error.
  ffi.Pointer<notmuch_config_pairs_t> notmuch_config_get_pairs(
    ffi.Pointer<notmuch_database_t> notmuch,
    ffi.Pointer<ffi.Int8> prefix,
  ) {
    return _notmuch_config_get_pairs(
      notmuch,
      prefix,
    );
  }

  late final _notmuch_config_get_pairsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<notmuch_config_pairs_t> Function(
              ffi.Pointer<notmuch_database_t>,
              ffi.Pointer<ffi.Int8>)>>('notmuch_config_get_pairs');
  late final _notmuch_config_get_pairs =
      _notmuch_config_get_pairsPtr.asFunction<
          ffi.Pointer<notmuch_config_pairs_t> Function(
              ffi.Pointer<notmuch_database_t>, ffi.Pointer<ffi.Int8>)>();

  /// Is the given 'config_pairs' iterator pointing at a valid element.
  ///
  /// @param[in] pairs iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval FALSE if passed a NULL pointer, or the iterator is exhausted.
  int notmuch_config_pairs_valid(
    ffi.Pointer<notmuch_config_pairs_t> pairs,
  ) {
    return _notmuch_config_pairs_valid(
      pairs,
    );
  }

  late final _notmuch_config_pairs_validPtr = _lookup<
          ffi.NativeFunction<
              notmuch_bool_t Function(ffi.Pointer<notmuch_config_pairs_t>)>>(
      'notmuch_config_pairs_valid');
  late final _notmuch_config_pairs_valid = _notmuch_config_pairs_validPtr
      .asFunction<int Function(ffi.Pointer<notmuch_config_pairs_t>)>();

  /// Move the 'config_pairs' iterator to the next element
  ///
  /// @param[in,out] pairs iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  void notmuch_config_pairs_move_to_next(
    ffi.Pointer<notmuch_config_pairs_t> pairs,
  ) {
    return _notmuch_config_pairs_move_to_next(
      pairs,
    );
  }

  late final _notmuch_config_pairs_move_to_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_pairs_t>)>>(
      'notmuch_config_pairs_move_to_next');
  late final _notmuch_config_pairs_move_to_next =
      _notmuch_config_pairs_move_to_nextPtr
          .asFunction<void Function(ffi.Pointer<notmuch_config_pairs_t>)>();

  /// Get the current key from the 'config_pairs' iterator
  ///
  /// @param[in] pairs iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval a string with the same lifetime as the iterator
  ffi.Pointer<ffi.Int8> notmuch_config_pairs_key(
    ffi.Pointer<notmuch_config_pairs_t> pairs,
  ) {
    return _notmuch_config_pairs_key(
      pairs,
    );
  }

  late final _notmuch_config_pairs_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<notmuch_config_pairs_t>)>>(
      'notmuch_config_pairs_key');
  late final _notmuch_config_pairs_key =
      _notmuch_config_pairs_keyPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_config_pairs_t>)>();

  /// Get the current value from the 'config_pairs' iterator
  ///
  /// @param[in] pairs iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval a string with the same lifetime as the iterator
  ffi.Pointer<ffi.Int8> notmuch_config_pairs_value(
    ffi.Pointer<notmuch_config_pairs_t> pairs,
  ) {
    return _notmuch_config_pairs_value(
      pairs,
    );
  }

  late final _notmuch_config_pairs_valuePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<notmuch_config_pairs_t>)>>(
      'notmuch_config_pairs_value');
  late final _notmuch_config_pairs_value =
      _notmuch_config_pairs_valuePtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_config_pairs_t>)>();

  /// Destroy a config_pairs iterator, along with any associated
  /// resources.
  ///
  /// @param[in,out] pairs iterator
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  void notmuch_config_pairs_destroy(
    ffi.Pointer<notmuch_config_pairs_t> pairs,
  ) {
    return _notmuch_config_pairs_destroy(
      pairs,
    );
  }

  late final _notmuch_config_pairs_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<notmuch_config_pairs_t>)>>(
      'notmuch_config_pairs_destroy');
  late final _notmuch_config_pairs_destroy = _notmuch_config_pairs_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_config_pairs_t>)>();

  /// get a configuration value from an open database as Boolean
  ///
  /// This value reflects all configuration information given at the time
  /// the database was opened.
  ///
  /// @param[in] notmuch database
  /// @param[in] key configuration key
  /// @param[out] val configuration value, converted to Boolean
  ///
  /// @since libnotmuch 5.4 (notmuch 0.32)
  ///
  /// @retval #NOTMUCH_STATUS_ILLEGAL_ARGUMENT if either key is unknown
  /// or the corresponding value does not convert to Boolean.
  int notmuch_config_get_bool(
    ffi.Pointer<notmuch_database_t> notmuch,
    int key,
    ffi.Pointer<notmuch_bool_t> val,
  ) {
    return _notmuch_config_get_bool(
      notmuch,
      key,
      val,
    );
  }

  late final _notmuch_config_get_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_database_t>, ffi.Int32,
              ffi.Pointer<notmuch_bool_t>)>>('notmuch_config_get_bool');
  late final _notmuch_config_get_bool = _notmuch_config_get_boolPtr.asFunction<
      int Function(
          ffi.Pointer<notmuch_database_t>, int, ffi.Pointer<notmuch_bool_t>)>();

  /// return the path of the config file loaded, if any
  ///
  /// @retval NULL if no config file was loaded
  ffi.Pointer<ffi.Int8> notmuch_config_path(
    ffi.Pointer<notmuch_database_t> notmuch,
  ) {
    return _notmuch_config_path(
      notmuch,
    );
  }

  late final _notmuch_config_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<notmuch_database_t>)>>('notmuch_config_path');
  late final _notmuch_config_path = _notmuch_config_pathPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<notmuch_database_t>)>();

  /// get the current default indexing options for a given database.
  ///
  /// This object will survive until the database itself is destroyed,
  /// but the caller may also release it earlier with
  /// notmuch_indexopts_destroy.
  ///
  /// This object represents a set of options on how a message can be
  /// added to the index.  At the moment it is a featureless stub.
  ///
  /// @since libnotmuch 5.1 (notmuch 0.26)
  /// @retval NULL in case of error
  ffi.Pointer<notmuch_indexopts_t> notmuch_database_get_default_indexopts(
    ffi.Pointer<notmuch_database_t> db,
  ) {
    return _notmuch_database_get_default_indexopts(
      db,
    );
  }

  late final _notmuch_database_get_default_indexoptsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<notmuch_indexopts_t> Function(
                  ffi.Pointer<notmuch_database_t>)>>(
      'notmuch_database_get_default_indexopts');
  late final _notmuch_database_get_default_indexopts =
      _notmuch_database_get_default_indexoptsPtr.asFunction<
          ffi.Pointer<notmuch_indexopts_t> Function(
              ffi.Pointer<notmuch_database_t>)>();

  /// Specify whether to decrypt encrypted parts while indexing.
  ///
  /// Be aware that the index is likely sufficient to reconstruct the
  /// cleartext of the message itself, so please ensure that the notmuch
  /// message index is adequately protected. DO NOT SET THIS FLAG TO TRUE
  /// without considering the security of your index.
  ///
  /// @since libnotmuch 5.1 (notmuch 0.26)
  int notmuch_indexopts_set_decrypt_policy(
    ffi.Pointer<notmuch_indexopts_t> indexopts,
    int decrypt_policy,
  ) {
    return _notmuch_indexopts_set_decrypt_policy(
      indexopts,
      decrypt_policy,
    );
  }

  late final _notmuch_indexopts_set_decrypt_policyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<notmuch_indexopts_t>,
              ffi.Int32)>>('notmuch_indexopts_set_decrypt_policy');
  late final _notmuch_indexopts_set_decrypt_policy =
      _notmuch_indexopts_set_decrypt_policyPtr
          .asFunction<int Function(ffi.Pointer<notmuch_indexopts_t>, int)>();

  /// Return whether to decrypt encrypted parts while indexing.
  /// see notmuch_indexopts_set_decrypt_policy.
  ///
  /// @since libnotmuch 5.1 (notmuch 0.26)
  int notmuch_indexopts_get_decrypt_policy(
    ffi.Pointer<notmuch_indexopts_t> indexopts,
  ) {
    return _notmuch_indexopts_get_decrypt_policy(
      indexopts,
    );
  }

  late final _notmuch_indexopts_get_decrypt_policyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<notmuch_indexopts_t>)>>(
      'notmuch_indexopts_get_decrypt_policy');
  late final _notmuch_indexopts_get_decrypt_policy =
      _notmuch_indexopts_get_decrypt_policyPtr
          .asFunction<int Function(ffi.Pointer<notmuch_indexopts_t>)>();

  /// Destroy a notmuch_indexopts_t object.
  ///
  /// @since libnotmuch 5.1 (notmuch 0.26)
  void notmuch_indexopts_destroy(
    ffi.Pointer<notmuch_indexopts_t> options,
  ) {
    return _notmuch_indexopts_destroy(
      options,
    );
  }

  late final _notmuch_indexopts_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<notmuch_indexopts_t>)>>('notmuch_indexopts_destroy');
  late final _notmuch_indexopts_destroy = _notmuch_indexopts_destroyPtr
      .asFunction<void Function(ffi.Pointer<notmuch_indexopts_t>)>();

  /// interrogate the library for compile time features
  ///
  /// @since libnotmuch 4.4 (notmuch 0.23)
  int notmuch_built_with(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _notmuch_built_with(
      name,
    );
  }

  late final _notmuch_built_withPtr = _lookup<
          ffi.NativeFunction<notmuch_bool_t Function(ffi.Pointer<ffi.Int8>)>>(
      'notmuch_built_with');
  late final _notmuch_built_with =
      _notmuch_built_withPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();
}

class __kernel_fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint64> fds_bits;
}

class __kernel_fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int32> val;
}

class __kernel_timespec extends ffi.Struct {
  @__kernel_time64_t()
  external int tv_sec;

  @ffi.Int64()
  external int tv_nsec;
}

typedef __kernel_time64_t = ffi.Int64;

class __kernel_itimerspec extends ffi.Struct {
  external __kernel_timespec it_interval;

  external __kernel_timespec it_value;
}

class __kernel_old_timeval extends ffi.Struct {
  @__kernel_long_t()
  external int tv_sec;

  @__kernel_long_t()
  external int tv_usec;
}

typedef __kernel_long_t = ffi.Int64;

class __kernel_old_timespec extends ffi.Struct {
  @__kernel_old_time_t()
  external int tv_sec;

  @ffi.Int64()
  external int tv_nsec;
}

typedef __kernel_old_time_t = __kernel_long_t;

class __kernel_old_itimerval extends ffi.Struct {
  external __kernel_old_timeval it_interval;

  external __kernel_old_timeval it_value;
}

class __kernel_sock_timeval extends ffi.Struct {
  @__s64()
  external int tv_sec;

  @__s64()
  external int tv_usec;
}

typedef __s64 = ffi.Int64;

class timespec extends ffi.Struct {
  @__kernel_old_time_t()
  external int tv_sec;

  @ffi.Int64()
  external int tv_nsec;
}

class timeval extends ffi.Struct {
  @__kernel_old_time_t()
  external int tv_sec;

  @__kernel_suseconds_t()
  external int tv_usec;
}

typedef __kernel_suseconds_t = __kernel_long_t;

class itimerspec extends ffi.Struct {
  external timespec it_interval;

  external timespec it_value;
}

class itimerval extends ffi.Struct {
  external timeval it_interval;

  external timeval it_value;
}

class timezone extends ffi.Struct {
  @ffi.Int32()
  external int tz_minuteswest;

  @ffi.Int32()
  external int tz_dsttime;
}

/// Status codes used for the return values of most functions.
///
/// A zero value (NOTMUCH_STATUS_SUCCESS) indicates that the function
/// completed without error. Any other value indicates an error.
abstract class notmuch_status_t {
  /// No error occurred.
  static const int NOTMUCH_STATUS_SUCCESS = 0;

  /// Out of memory.
  static const int NOTMUCH_STATUS_OUT_OF_MEMORY = 1;

  /// An attempt was made to write to a database opened in read-only
  /// mode.
  static const int NOTMUCH_STATUS_READ_ONLY_DATABASE = 2;

  /// A Xapian exception occurred.
  ///
  /// @todo We don't really want to expose this lame XAPIAN_EXCEPTION
  /// value. Instead we should map to things like DATABASE_LOCKED or
  /// whatever.
  static const int NOTMUCH_STATUS_XAPIAN_EXCEPTION = 3;

  /// An error occurred trying to read or write to a file (this could
  /// be file not found, permission denied, etc.)
  static const int NOTMUCH_STATUS_FILE_ERROR = 4;

  /// A file was presented that doesn't appear to be an email
  /// message.
  static const int NOTMUCH_STATUS_FILE_NOT_EMAIL = 5;

  /// A file contains a message ID that is identical to a message
  /// already in the database.
  static const int NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID = 6;

  /// The user erroneously passed a NULL pointer to a notmuch
  /// function.
  static const int NOTMUCH_STATUS_NULL_POINTER = 7;

  /// A tag value is too long (exceeds NOTMUCH_TAG_MAX).
  static const int NOTMUCH_STATUS_TAG_TOO_LONG = 8;

  /// The notmuch_message_thaw function has been called more times
  /// than notmuch_message_freeze.
  static const int NOTMUCH_STATUS_UNBALANCED_FREEZE_THAW = 9;

  /// notmuch_database_end_atomic has been called more times than
  /// notmuch_database_begin_atomic.
  static const int NOTMUCH_STATUS_UNBALANCED_ATOMIC = 10;

  /// The operation is not supported.
  static const int NOTMUCH_STATUS_UNSUPPORTED_OPERATION = 11;

  /// The operation requires a database upgrade.
  static const int NOTMUCH_STATUS_UPGRADE_REQUIRED = 12;

  /// There is a problem with the proposed path, e.g. a relative path
  /// passed to a function expecting an absolute path.
  static const int NOTMUCH_STATUS_PATH_ERROR = 13;

  /// The requested operation was ignored. Depending on the function,
  /// this may not be an actual error.
  static const int NOTMUCH_STATUS_IGNORED = 14;

  /// One of the arguments violates the preconditions for the
  /// function, in a way not covered by a more specific argument.
  static const int NOTMUCH_STATUS_ILLEGAL_ARGUMENT = 15;

  /// A MIME object claimed to have cryptographic protection which
  /// notmuch tried to handle, but the protocol was not specified in
  /// an intelligible way.
  static const int NOTMUCH_STATUS_MALFORMED_CRYPTO_PROTOCOL = 16;

  /// Notmuch attempted to do crypto processing, but could not
  /// initialize the engine needed to do so.
  static const int NOTMUCH_STATUS_FAILED_CRYPTO_CONTEXT_CREATION = 17;

  /// A MIME object claimed to have cryptographic protection, and
  /// notmuch attempted to process it, but the specific protocol was
  /// something that notmuch doesn't know how to handle.
  static const int NOTMUCH_STATUS_UNKNOWN_CRYPTO_PROTOCOL = 18;

  /// Unable to load a config file
  static const int NOTMUCH_STATUS_NO_CONFIG = 19;

  /// Unable to load a database
  static const int NOTMUCH_STATUS_NO_DATABASE = 20;

  /// Database exists, so not (re)-created
  static const int NOTMUCH_STATUS_DATABASE_EXISTS = 21;

  /// Syntax error in query
  static const int NOTMUCH_STATUS_BAD_QUERY_SYNTAX = 22;

  /// Not an actual status value. Just a way to find out how many
  /// valid status values there are.
  static const int NOTMUCH_STATUS_LAST_STATUS = 23;
}

class _notmuch_database extends ffi.Opaque {}

class _notmuch_query extends ffi.Opaque {}

class _notmuch_threads extends ffi.Opaque {}

class _notmuch_thread extends ffi.Opaque {}

class _notmuch_messages extends ffi.Opaque {}

class _notmuch_message extends ffi.Opaque {}

class _notmuch_tags extends ffi.Opaque {}

class _notmuch_directory extends ffi.Opaque {}

class _notmuch_filenames extends ffi.Opaque {}

class _notmuch_config_list extends ffi.Opaque {}

class _notmuch_config_values extends ffi.Opaque {}

class _notmuch_config_pairs extends ffi.Opaque {}

class _notmuch_indexopts extends ffi.Opaque {}

typedef notmuch_database_t = _notmuch_database;

/// Database open mode for notmuch_database_open.
abstract class notmuch_database_mode_t {
  /// Open database for reading only.
  static const int NOTMUCH_DATABASE_MODE_READ_ONLY = 0;

  /// Open database for reading and writing.
  static const int NOTMUCH_DATABASE_MODE_READ_WRITE = 1;
}

/// A callback invoked by notmuch_database_compact to notify the user
/// of the progress of the compaction process.
typedef notmuch_compact_status_cb_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Void>)>>;

/// Notmuch boolean type.
typedef notmuch_bool_t = ffi.Int32;
typedef notmuch_directory_t = _notmuch_directory;
typedef notmuch_indexopts_t = _notmuch_indexopts;
typedef notmuch_message_t = _notmuch_message;
typedef notmuch_tags_t = _notmuch_tags;
typedef notmuch_query_t = _notmuch_query;

abstract class notmuch_query_syntax_t {
  static const int NOTMUCH_QUERY_SYNTAX_XAPIAN = 0;
  static const int NOTMUCH_QUERY_SYNTAX_SEXP = 1;
}

/// Sort values for notmuch_query_set_sort.
abstract class notmuch_sort_t {
  /// Oldest first.
  static const int NOTMUCH_SORT_OLDEST_FIRST = 0;

  /// Newest first.
  static const int NOTMUCH_SORT_NEWEST_FIRST = 1;

  /// Sort by message-id.
  static const int NOTMUCH_SORT_MESSAGE_ID = 2;

  /// Do not sort.
  static const int NOTMUCH_SORT_UNSORTED = 3;
}

/// Exclude values for notmuch_query_set_omit_excluded. The strange
/// order is to maintain backward compatibility: the old FALSE/TRUE
/// options correspond to the new
/// NOTMUCH_EXCLUDE_FLAG/NOTMUCH_EXCLUDE_TRUE options.
abstract class notmuch_exclude_t {
  static const int NOTMUCH_EXCLUDE_FLAG = 0;
  static const int NOTMUCH_EXCLUDE_TRUE = 1;
  static const int NOTMUCH_EXCLUDE_FALSE = 2;
  static const int NOTMUCH_EXCLUDE_ALL = 3;
}

typedef notmuch_threads_t = _notmuch_threads;
typedef notmuch_messages_t = _notmuch_messages;
typedef notmuch_thread_t = _notmuch_thread;
typedef notmuch_filenames_t = _notmuch_filenames;

/// Message flags.
abstract class notmuch_message_flag_t {
  static const int NOTMUCH_MESSAGE_FLAG_MATCH = 0;
  static const int NOTMUCH_MESSAGE_FLAG_EXCLUDED = 1;
  static const int NOTMUCH_MESSAGE_FLAG_GHOST = 2;
}

class _notmuch_string_map_iterator extends ffi.Opaque {}

/// Opaque message property iterator
typedef notmuch_message_properties_t = _notmuch_string_map_iterator;
typedef notmuch_config_list_t = _notmuch_config_list;

/// Configuration keys known to libnotmuch
abstract class notmuch_config_key_t {
  static const int NOTMUCH_CONFIG_FIRST = 0;
  static const int NOTMUCH_CONFIG_DATABASE_PATH = 0;
  static const int NOTMUCH_CONFIG_MAIL_ROOT = 1;
  static const int NOTMUCH_CONFIG_HOOK_DIR = 2;
  static const int NOTMUCH_CONFIG_BACKUP_DIR = 3;
  static const int NOTMUCH_CONFIG_EXCLUDE_TAGS = 4;
  static const int NOTMUCH_CONFIG_NEW_TAGS = 5;
  static const int NOTMUCH_CONFIG_NEW_IGNORE = 6;
  static const int NOTMUCH_CONFIG_SYNC_MAILDIR_FLAGS = 7;
  static const int NOTMUCH_CONFIG_PRIMARY_EMAIL = 8;
  static const int NOTMUCH_CONFIG_OTHER_EMAIL = 9;
  static const int NOTMUCH_CONFIG_USER_NAME = 10;
  static const int NOTMUCH_CONFIG_AUTOCOMMIT = 11;
  static const int NOTMUCH_CONFIG_LAST = 12;
}

typedef notmuch_config_values_t = _notmuch_config_values;
typedef notmuch_config_pairs_t = _notmuch_config_pairs;

/// Stating a policy about how to decrypt messages.
///
/// See index.decrypt in notmuch-config(1) for more details.
abstract class notmuch_decryption_policy_t {
  static const int NOTMUCH_DECRYPT_FALSE = 0;
  static const int NOTMUCH_DECRYPT_TRUE = 1;
  static const int NOTMUCH_DECRYPT_AUTO = 2;
  static const int NOTMUCH_DECRYPT_NOSTASH = 3;
}

const int __BITS_PER_LONG = 64;

const int __FD_SETSIZE = 1024;

const int ITIMER_REAL = 0;

const int ITIMER_VIRTUAL = 1;

const int ITIMER_PROF = 2;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_SGI_CYCLE = 10;

const int CLOCK_TAI = 11;

const int MAX_CLOCKS = 16;

const int CLOCKS_MASK = 1;

const int CLOCKS_MONO = 1;

const int TIMER_ABSTIME = 1;

const int FALSE = 0;

const int TRUE = 1;

const int LIBNOTMUCH_MAJOR_VERSION = 5;

const int LIBNOTMUCH_MINOR_VERSION = 5;

const int LIBNOTMUCH_MICRO_VERSION = 0;

const int NOTMUCH_TAG_MAX = 200;
